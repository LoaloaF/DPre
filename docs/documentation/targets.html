<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.1" />
<title>main.targets API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>main.targets</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import pandas as pd
import numpy as np
import sys
import os
import copy
import matplotlib.pyplot as plt
from matplotlib.colors import is_color_like
from matplotlib.lines import Line2D
from scipy.spatial import distance

from DPre.main._differential import _differential
from DPre.main.samples import samples
from DPre.main._logger import spacer, logger, log_plot
import DPre.main.config as config
import DPre.main._dpre_util as util

class targets(_differential):
    &#34;&#34;&#34;The data to compare similarity against.

    targets can hold lists of marker genes and expression data identifying a 
    collection of comparative transcriptional identities, the targets. 

    Arguments:
        marker genes (optional): Directory with deseq2 output, directories 
            with up- and (optional) down gene lists or pandas.DataFrame. 
            Defaults to None. Gene list data has an ensg key in the first column 
            or contains an &#39;ensg&#39; column label. &#39;Up-marker genes&#39; should list 
            genes highly expressed in targets, &#39;down-marker genes&#39; are those 
            expected to be low. When passing a DataFrame, the index should 
            consist of ensg keys, the columns of a pandas.MultiIndex with &#39;up&#39; 
            or &#39;up&#39; &amp; &#39;down&#39; at level 0 and the element names at level 1. 
            The dtype is bool, marker genes are stored as &#39;True&#39;. If None, all 
            expression values are considered as &#39;marker genes&#39;.
        expression (optional): TSV expression file or pandas.DataFrame. 
            Defaults to None.
            The TSV input should have an ensg key in the first column or an ensg 
            column label. Columns `loc`, `name`, `tss_loc` and `strand` are 
            removed automatically. The data should be exclusively numerical 
            without NaN&#39;s. When passing a DataFrame, the data can be log2- 
            and z-transformed with an ensg key index and pandas.MultiIndex 
            columns with the element names at level 0, and `log2` &amp; `z` at 
            level 1. 
        ignore_down_mgs (bool, optional): Even if found in &#39;marker gene&#39; input, 
            do not use the down marker genes for the analysis. Defaults to False.
        override_namematcher (bool, optional): When both &#39;marker genes&#39; and 
            &#39;expression&#39; passed, this overrides the element names in 
            &#39;marker genes&#39;. Defaults to False. When False, element names in 
            &#39;marker genes&#39; and &#39;expression&#39; are expected to match perfectly.
        name (str, optional): Name label of the targets. Defaults to &#39;Targets&#39;. 
            Used in logging and plot annotations.
        species (str, optinoal): Species of the targets instance. Can be &#39;mouse&#39;
            or &#39;human&#39;. Defaults to None. This is required when genes are 
            annotated for the gene_similarity_heatmap function.
        log: (bool, optional): Log the targets initiation. Defaults to True.
        
    Note:
        At least one of &#39;diff_genes&#39; and &#39;expression&#39; must be passed. When both 
        are passed, the inputs must have the same element order. Gene list
        data is automatically alphabetically sorted, hence the expression order
        should concur with this.
    &#34;&#34;&#34;
    def __init__(self, markergenes=None, expression=None, name=None, 
                 ignore_down_mgs=False, override_namematcher=False, 
                 species=None, log=True):
        # call _differential __init__ method
        super().__init__(diff_genes=markergenes, expression=expression, 
                         name=name, override_namematcher=override_namematcher, 
                         log=log)
        # define if down marker genes are used
        self._down_mgs = not ignore_down_mgs
        self._species = species 

        self._trg_sims = {}
        self._gene_sims = {}
        
        # remove down mgs from _diff if in there but not desired by the user
        if self._has_diff:
            if not self._down_mgs and &#39;down&#39; in self._diff.columns.unique(0):
                self._diff.drop(&#39;down&#39;, axis=1, level=0, inplace=True)
            elif &#39;down&#39; not in self._diff.columns.unique(0) and self._down_mgs:
                self._down_mgs = False
            if log:
                spacer.info(&#39;&#39;)
                n = self._diff.sum().unstack(0).reindex(self.names).to_string()
                logger.info(&#39;Number of marker genes: \n{}&#39;.format(n))
        # inform that not passing marker genes is not recommended
        elif log:
            self._down_mgs = False
            spacer.warning(&#39;&#39;)
            logger.warning(&#39;The targets `{}` are initiated without &#39;
                           &#39;`marker genes`. Note that comparing against all &#39;
                           &#39;genes can lead to low accuracy for defining &#39;
                           &#39;transcriptional similarity.&#39;.format(self.name))
        
        # _expr_mgs store
        # s a mask of _expr that holds only the marker genes
        if self._has_expr:
            expr_mgs = util._add_mg_types(self._expr.copy(), self._down_mgs)
            if self._has_diff: 
                mg_mask = lambda trg: trg.mask(~self._diff[trg.columns[0][:-1]])
                expr_mgs = expr_mgs.groupby(level=(0,1), axis=1).apply(mg_mask)
                self._expr_mgs = expr_mgs.reindex(self._mgs)
            else:
                self._expr_mgs = expr_mgs
        if log:
            spacer.info(&#39;\n\n&#39;)
        self._log_init(log)

    def __repr__(self):
        &#34;&#34;&#34;Get a readable summary of the samples instance&#34;&#34;&#34;
        return (&#39;\n=|=|= targets-instance =|=|=\nname = {};\nelements = {};\n&#39;
                &#39;n = {};\nmarker genes data = {};\nexpression data = {}\n&#39;
                .format(self.name, self.names, len(self), self._has_diff, 
                        self._has_expr))
    @property
    def _mgs(self):
        &#34;&#34;&#34;Get the genes that are at least the marker gene of one target&#34;&#34;&#34;
        if self._has_diff:
            return self._diff[self._diff.any(1)].index
        elif self._has_expr:
            return self._expr[self._expr.any(1)].index

    @property
    def _mg_types(self):
        &#34;&#34;&#34;Get the marker gene types present in the targets instance&#34;&#34;&#34;
        return [&#39;up&#39;, &#39;down&#39;] if self._down_mgs else [&#39;up&#39;]

    def _compute_similarity(self, samples, metric, log=True):
        &#34;&#34;&#34;Core function computing the similarity between samples and targets
            for metrics &#39;euclid&#39;, &#39;intersect&#39; &#39;cosine&#39; and &#39;pearson&#39;. A 
            similarity matrix with the respective samples is stored in trg_sims 
            and gene_sim.
        &#34;&#34;&#34;
        # check marker gene detection before computing similarity
        det = self.plot_detec_mgs_prop(samples, filename=None, log=log)
        det = det.reindex(self.names, level=1)
        keep = det[det.proportion &gt;config.DROP_TARGET_DETEC_THR].index.unique(1)
        if len(keep) != len(self):
            # drop targets with too few detected genes
            dr = pd.Index(self.names).difference(keep).tolist()
            if log:
                logger.info(&#39;{} target elements dropped due to marker gene &#39;
                            &#39;detection proportions lower {} &#39;&#39;(set in &#39;
                            &#39;config.DROP_TARGET_DETEC_THR):\n{}&#39;
                            .format(len(dr), config.DROP_TARGET_DETEC_THR, dr))
            self.slice_elements(keep, inplace=True, log=False)
            # self._compute_similarity(samples, metric log=log)
        if log:
            spacer.info(&#39;&#39;)
            logger.info(&#39;Computing similarity `{}` of samples `{}` and targets: &#39;
                        &#39;`{}` ... &#39;.format(metric, samples.name, self.name))
        # get expression data or gene list data of samples and targets
        if metric != &#39;intersect&#39;:
            # get the z-data of targets marker genes and all samples genes
            trg_data = self._expr_mgs.xs(&#39;z&#39;, 1, 2)
            smp_data = samples._expr.xs(&#39;z&#39;, 1, 1)
        else:
            # get gene list data (bool) and substitute diff data with +1 for 
            # up genes, -1 for down. Samples up and down lists are merged
            smp_data = util._bool_to_int_genes(samples._diff, return_merged=True)
            diff_mgs = self._diff.reindex(self._mgs)
            trg_data = util._bool_to_int_genes(diff_mgs, trans_updown=False)
            trg_data.mask(trg_data == 0, inplace=True)
        
        def compute_trg_sim(trg_d):
            det = trg_d.index[trg_d.notna()].intersection(smp_data.index)
            trg = trg_d.reindex(det)
            smp_d = smp_data.reindex(det)
            if metric == &#39;cosine&#39;:
                return smp_d.apply(lambda smp: (distance.cosine(smp, trg)-1)*-1)
            elif metric == &#39;pearson&#39;:
                return smp_d.apply(lambda smp: (distance.correlation(smp, trg)-1)*-1)
            else:
                # additionally save per gene similarity matrix here
                if metric == &#39;euclid&#39;:
                    gene_sims.append(smp_d.apply(lambda smp: abs(smp-trg)))
                    return gene_sims[-1].abs().mean()
                elif metric == &#39;intersect&#39;:
                    # this returns a matric representing matches and mismatches
                    gene_sims.append(smp_d.apply(lambda smp_d: abs(smp_d+trg) -1))
                    return gene_sims[-1].mean()
        if metric in [&#39;euclid&#39;, &#39;intersect&#39;]:
            gene_sims = []
            trg_sim = trg_data.apply(compute_trg_sim)
            
            # per gene data saving
            gene_sim = pd.concat(gene_sims, axis=1, sort=False)
            idx = [*[trg_data.columns.unique(i) for i in (0,1)], smp_data.columns]
            gene_sim.columns = pd.MultiIndex.from_product(idx)
            self._gene_sims[&#39;{}-{}&#39;.format(id(samples), metric)] = gene_sim
        else:
            trg_sim = trg_data.apply(compute_trg_sim)
        trg_sim = util._add_mgtmean(trg_sim)
        self._trg_sims[&#39;{}-{}&#39;.format(id(samples), metric)] = trg_sim

    def _get_similarity(self, samples, metric, which_sim=&#39;target_sim&#39;, 
                          differential=False, drop_ctrl=True, 
                          inters_to_updown_not=False, log=True):
        &#34;&#34;&#34;Specifically access target similarity (trg_sims) and gene similarity 
            (gene_sims) data. Returns 2 elements, either target similarity and 
            ctrl target similarity or per gene similarity and per gene control 
            similarity. Option for differential and absolute similarities.
        &#34;&#34;&#34;
        # check if similarity has already been computed, if not do similarity
        try:
            key = &#39;{}-{}&#39;.format(id(samples), metric)
            trg_sim = self._trg_sims[key].copy()
        except KeyError:
            self._compute_similarity(samples, metric, log=log)
            trg_sim = self._trg_sims[key].copy()
        if log:
            logger.info(&#39;Selecting and processing similarity data...&#39;)

        # ensure the similarity matrix has the correct ordering 
        t_ord = trg_sim.columns.unique(1)
        val_t_ord = pd.Index(self.names)
        val_t_ord = val_t_ord.drop(val_t_ord.difference(t_ord))
        if t_ord.tolist() != val_t_ord.tolist():
            trg_sim = trg_sim.reindex(val_t_ord, level=1, axis=1)
        s_ord = trg_sim.index
        val_s_ord = samples.names
        if s_ord.tolist() != val_s_ord:
            trg_sim = trg_sim.reindex(val_s_ord)

        # return target similarity
        if which_sim == &#39;target_sim&#39;:
            sim = trg_sim
            # expression based metrics
            if metric != &#39;intersect&#39;:
                if samples._ctrl:
                    ctrl_sim = sim.xs(samples._ctrl, drop_level=False)
                    if drop_ctrl:
                        sim.drop(samples._ctrl, inplace=True)
                    if differential:
                        sim = sim.apply(lambda smp: smp - ctrl_sim, axis=1)
                        # return not change but the reduction in Eucl. dist.
                        if metric == &#39;euclid&#39;:
                            sim *= -1
                    return sim, ctrl_sim.to_frame().T
                else:
                    return sim, None
            # gene list based metrics (intersect is differential by itself)
            else:
                if samples._ctrl and drop_ctrl:
                    sim.drop(samples._ctrl, inplace=True)
                # instead of a control, the number of marker genes are returned
                n_mgs = self._diff.sum()
                n_mgs = n_mgs.append(n_mgs.groupby(level=1, axis=0).mean())
                return sim, pd.DataFrame([n_mgs.values], [&#39;n_mgs&#39;], sim.columns)
        
        # return gene similarity, only available for euclid and intersect metric
        elif which_sim == &#39;gene_sim&#39;:
            sim = self._gene_sims[key].copy()
            if metric == &#39;euclid&#39;:
                if samples._ctrl:
                    ctrl_sim = sim.xs(samples._ctrl, 1, 2, drop_level=False)
                    if drop_ctrl:
                        sim.drop(samples._ctrl, axis=1, level=2, inplace=True)
                    if differential:
                        c_mask = np.repeat(ctrl_sim.values, axis=1, 
                                           repeats=len(sim.columns.unique(2)))
                        sim = c_mask - sim
                    return sim, ctrl_sim
                else:
                    return sim, None
            elif metric == &#39;intersect&#39;:
                if samples._ctrl and drop_ctrl:
                    sim.drop(samples._ctrl, axis=1, level=2, inplace=True)
                # by default sim holds matches (1) and mismatches (-1) 
                # this option makes -1 the positive value for down-marker genes
                if inters_to_updown_not and self._down_mgs:
                    sim[&#39;down&#39;] *= -1
                return sim, None
            
    def plot_detec_mgs_prop(self, samples, plt_show=False, 
                            filename=None, specific_target_labels=None, log=True):
        &#34;&#34;&#34;Show the proportion of detected marker genes in logs and a histogram.

            Useful for adjusting the DROP_TARGET_DETEC_THR value.

            Args:
                samples (samples): The samples instance to check the detection 
                    rate for.
                plt_show (bool, optional): Directly the histogram in a new
                    window. Defaults to False.
                filename (str, optional): Filename to save the generated 
                    histogram. Defaults to detec_mgs_prop. + config.SAVE_FORMAT.
                    None results in no file being saved.
                specific_target_labels (list, optional): define a specific set 
                    of target labels to display. Defaults to None
            Returns:
                det: A DataFrame with detection values used for logging and 
                    plotting
            Note:
                When the proportion of detection is at 0 for all targetss, an 
                error is raised.
        &#34;&#34;&#34;
        # get proportion of detected marker genes
        if self._has_diff:
            trg_d = self._diff
        elif self._has_expr:
            cols = pd.MultiIndex.from_product((self._mg_types, self.names))
            trg_d = pd.DataFrame(True, self._expr.index, cols)
        smp_from = samples._expr if samples._has_expr else samples._diff
        smp_d = smp_from.reindex(self._mgs).notna().iloc(1)[0]
        det = trg_d.reindex(self._mgs).apply(lambda trg: trg &amp; smp_d).sum()
        n_mgs = trg_d.sum()
        order = (det/n_mgs).sort_values().index

        # log proportion of detected marker genes
        det = pd.DataFrame({&#39;n marker genes&#39;: n_mgs.reindex(order), 
                            &#39;detected in samples&#39;: det.reindex(order).values, 
                            &#39;proportion&#39;: (det/n_mgs).reindex(order).values})
        n_trgs = 10 if not len(order) &lt;20 else int(len(order)/2)
        edges = order.droplevel(0)[:n_trgs].append(order.droplevel(0)[-n_trgs:])
        df_edges = det.loc[(slice(None), edges), :].to_string()
        if log:
            spacer.info(&#39;&#39;)
            logger.info(&#39;Detection of targets ({}) marker genes in samples data &#39;
                        &#39;({}): \n{}\nShown are the {} edge proportion values.&#39;
                        .format(self.name, samples.name, df_edges, len(edges)))
        if (det[&#39;detected in samples&#39;] == 0).all():
            trg_genes = &#39;, &#39;.join(self._detec_genes[:3])
            smp_genes = &#39;, &#39;.join(samples._expr.index[:3]) if samples._has_expr \
                        else &#39;, &#39;.join(samples._diff.index[:3])
            msg = (&#39;None of the targets marker genes were detected in the &#39;
                   &#39;samples. This is likely due to non-matching indeces from a &#39;
                   &#39;species-mismatch. Targets gene index: {} ... Samples gene &#39;
                   &#39;index: {}. Check the input files.&#39;
                   .format(trg_genes, smp_genes))
            logger.error(msg)
            sys.exit(1)
        # draw the plot if filename is passed, otherwise only log and return df
        if filename or plt_show:
            if filename:
                filename, pp = util._open_file(filename)
            fig, ax = plt.subplots()
            ax.bar(np.arange(len(order)), det.proportion, edgecolor=&#39;k&#39;,
                   width=1, color=self.get_colors(order.get_level_values(1)))
            ax.hlines(config.DROP_TARGET_DETEC_THR, 0, len(self))
            ax.yaxis.grid(alpha=0.8, linestyle=&#39;dashed&#39;)
            ax.set_xlabel(self.name+&#39; (targets)&#39;)
            if specific_target_labels:
                xlbl = [lbl if lbl in specific_target_labels else &#39;&#39; 
                        for lbl in order]
                ax.set_xticks(np.arange(len(xlbl)))
                ax.set_xticklabels(xlbl, rotation=45, ha=&#39;right&#39;, 
                                rotation_mode=&#39;anchor&#39;)
            ax.set_ylabel(&#39;Proportion of detected marker genes in samples&#39;)
            tit = (&#39;Proportion of detected {} marker genes in {}\nline = drop &#39;
                   &#39;threshold&#39;).format(self.name, samples.name)
            ax.set_title(tit, fontsize=6)
            if plt_show:
                plt.show()
            if filename:
                util._save_file(fig, filename, pp, close_pp=True)
                logger.info(&#39;Plot saved at {}\n&#39;
                            .format(os.path.abspath(filename)))
            else:
                plt.close()
        return det

    def target_similarity_heatmap(self, 
                                  # plot data
                                  samples, 
                                  metric = None, 
                                  differential = True,
                                  display_markergenes = &#39;mean&#39;,
                                  # data ordering
                                  cluster_targets = False,
                                  cluster_samples = False,
                                  reorder_to_distance_bar = False,
                                  # general settings
                                  pivot = False,
                                  heatmap_width = None,
                                  heatmap_height = None,
                                  heatmap_range = None,
                                  distance_bar_range = None,
                                  specific_target_labels = None,
                                  targetlabels_space = None,
                                  samplelabels_space = None,
                                  targetlabels_size = None,
                                  samplelabels_size = None,
                                  title = True, 
                                  # show/ hide elements 
                                  hide_colorbar_legend = False,
                                  hide_distance_bar = False,
                                  hide_targetlabels = False,
                                  hide_targets_dendrogram = False,
                                  hide_targets_colorbar = False,
                                  hide_samplelabels = False,
                                  show_samples_dendrogram = False,
                                  show_samples_colorbar = False,
                                  # others
                                  plt_show = False,
                                  filename = &#39;target_similarity_hm&#39;,
                                  **kwargs):
        &#34;&#34;&#34;Plot the similarity of the samples with the targets in a heatmap.
        
        This gives a compact insight on transcriptional similarity with the 
        targets. Four different metrics can be picked to assess similarity: 
        &#39;euclid&#39;, &#39;cosine&#39; and &#39;pearson&#39; for expression inputs or &#39;intersect&#39; 
        for comparison based on diff. genes/ marker genes. Differential and 
        absolute similarity values are available options for investigating the 
        change or state in similarity with the targets.

        Args:
            =================== Plot data options ===================
            samples (samples): the data to rate similarity for.
            metric (str, optional): the similarity metric to use. Valid 
                options are &#39;euclid&#39;, &#39;intersect&#39;, &#39;cosine&#39;, &#39;pearson&#39;. Defaults 
                to None.&#39;euclid&#39; shows the mean euclidean distance towards the 
                target marker genes expression levels and requires `expression` 
                input for samples and targets. &#39;intersect&#39; will show the overlap 
                between diff. sample genes and target marker genes requiring 
                gene list input. &#39;cosine&#39; will compute the cosine similarity, 
                &#39;pearson&#39; the Pearson correlation coefficient. More details in
                publication. When None, set to &#39;cosine&#39; when expression input 
                was passed, or &#39;intersect&#39; when gene list data was passed.
            differential (bool, optional): plot the differential (change in)
                similarity from the untreated-,/ base-sample, or. the control 
                to other samples. Defaults to True. Requires a control to be 
                passed for the expression-based metrics. Cannot be False for 
                &#39;intersect&#39;-metric.
            display_markergenes (str, optional): specify the group of 
                marker genes to display similarity for. Defaults to &#39;mean&#39;. 
                Valid options are &#39;mean&#39;, &#39;up&#39;, &#39;down&#39;. Relevent when targets 
                are initiated with down-marker genes.

            =================== data ordering options ===================
            cluster_targets (bool, optional): cluster targets using the 
                euclidean distance. Defaults to False.
            cluster_samples (bool, optional): cluster samples using the 
                euclidean distance. Defaults to False.
            reorder_to_distance_bar (bool, optional): reorder the targets
                from lowest to highest base distance. Defaults to False. 
                Cannot be True when  &#39;cluster_targets&#39; is True aswell.
                For details, check the &#39;hide_distance_bar&#39; argument. 

            =================== general visual options ===================
            pivot (bool, optional): pivot the heatmap by 90 degrees. Defaults to 
                False. Useful for fitting the heatmap on a canvas. 
            heatmap_width (float, optional): multiplier to stretch/ squeeze 
                the heatmap squares in x direction. Defaults to None. 
                Useful for very low or high number of targets. For pivot = True
                this paramter controls the height. 
            heatmap_height (float, optional): multiplier to stretch/ squeeze 
                the heatmap squares in y direction. Defaults to None. 
                Useful for very low or high number of samples. For pivot = True
                this paramter controls the width. 
            distance_bar_range (list, optional): Define the range of values
                that form the colormap for the distance bar. Defaults to
                None. The list is interpreted as, [lower_limit, upper_limit]. 
                When None, the edges are defined to cover all occuring values. 
                
            specific_target_labels (list, optional): define a specific set of
                target labels to display. Defaults to None
            targetlabels_space (float, optional): define the size in inches
                to reserve for target labels, here, the white space on the
                bottom. Defaults to None. When None, refer to the values set in 
                config.HM_BOTTOM.
            samplelabels_space (float, optional): define the size in inches
                to reserve for sample labels, here, the white space on the
                left. Defaults to None. When None, refer to the value set in 
                config.HM_LEFT.
            targetlabels_size (float, optional): multiplier for adjusting 
                target label size. Defaults to None. Useful for very high or low 
                number of targets.
            samplelabels_size (float, optional): multiplier for adjusting 
                sample label size. Defaults to None. Useful for very high or low 
                number of samples.
            title (bool, str, optional): the plot title to set. Defaults to 
                True. For True, infer the title based on plot data inputs and 
                targets/ samples name attribute. Text input will be set as 
                the general title, False hides the title.
            kwargs: modify the constants defined in config. This is used as an 
                advanced adjustment of plot element sizes and the minimum 
                required marker genes detection proportion. This heatmap may be
                adjusted by the following paramters: DROP_TARGET_DETEC_THR,
                HM_LEFT, HM_TOP, HM_RIGHT, HM_BOTTOM, HM_WSPACE, 
                HM_HSPACE, HM_Y_COLORBAR, HM_X_COLORBAR, HM_DISTANCE_BAR, 
                HM_Y_DENDROGRAM, HM_X_DENDROGRAM, HM_SQUARE_SIZE, CB_LEFT, 
                CB_LEFT_SEC, CB_TOP, CB_WIDTH, CB_HEIGHT.
            
            =================== hide/show plot elements ===================
            hide_colorbar_legend (bool, optional): Do not plot the colorbar 
                legend. Defaults to False. Applies for all colorbar_legends.
            hide_distance_bar (bool, optional): Do not plot the distance 
                bar on top of the heatmap. Defaults to False. When True, the 
                control will appear in the main heatmap. For the expression-
                based metrics, this bar visualizes the absolute similarity of 
                the control with the targets. For the &#39;intersect&#39; metric, the 
                number of target marker genes is shown. Defaults to False.
            hide_targetlabels (bool, optional): Do not plot the target 
                labels at the bottom. Defaults to False.
            hide_targets_dendrogram (bool, optional): Do not plot the 
                targets dendrogram from clustering. Defaults to False. 
                Requires &#39;cluster_targets&#39; to be True. 
            hide_targets_colorbar (bool, optional): Do not plot the targets
                colorbar on the bottom of the heatmap. Defaults to False. 
                When colors are not set for the targets using the 
                set_colors() function, colors are set to white.
            hide_samplelabels (bool, optional): Do not plot the sample 
                labels at the left. Defaults to False.
            show_samples_dendrogram (bool, optional): Plot the samples 
                dendrogram from clustering. Defaults to False. Requires 
                &#39;cluster_samples&#39; to be True.
            show_samples_colorbar (bool, optional): Plot the samples
                colorbar on the left of the heatmap. Defaults to False. 
                When colors are not set for the targets using the 
                set_colors() function, colors are set to white. 

            =================== others ===================
            filename (str, optional): the filename for saving the figure.
                Defaults to &#39;target_similarity_hm.png&#39;. Supported filename 
                endings are .png and .pdf. If filename does not end with 
                these, the filetype is retrieved from conifg.SAVE_FORMAT.
                If None, the plot is not saved.
            plt_show (bool, optional): directly show the created plot in a new
                window. Defaults to False.
        &#34;&#34;&#34;
        # check user input for errors and incompatibilities
        def _check_args():
            nonlocal metric
            nonlocal differential

            nonlocal cluster_targets
            nonlocal reorder_to_distance_bar
            nonlocal hide_distance_bar
            nonlocal display_markergenes
            nonlocal distance_bar_range

            # check general basic input requirements
            r = util._check_args(self, samples, metric, differential, 
                                hide_distance_bar, reorder_to_distance_bar,
                                distance_bar_range, cluster_targets, 
                                display_markergenes)
            metric, differential, hide_distance_bar, reorder_to_distance_bar, \
            distance_bar_range, cluster_targets, display_markergenes = r
                
            config._update_consts(kwargs)
            spacer.info(&#39;&#39;)
            logger.info(&#39;Arguments passed. Getting data now ...&#39;)

        # get the specific similarity data, plot the mean of up and down mgs
        def get_data():
            sim, ctrl_sim = self._get_similarity(samples, metric, 
                                                 differential=differential,
                                                 drop_ctrl= not hide_distance_bar)
            if ctrl_sim is None:
                ctrl_sim =  pd.DataFrame(0, [0], sim.columns)
            return [sim.xs(display_markergenes, 1, 0), 
                    ctrl_sim.xs(display_markergenes, 1, 0)]

        # get plot lims
        def get_caps():
            # get min and max value in data, set to caps
            if heatmap_range is not None:
                low_cap, up_cap = heatmap_range
            else:
                mini = abs(data[0].min().min())
                maxi = abs(data[0].max().max())
                up_cap = round(max((mini, maxi)), 1)
                low_cap = -up_cap
            # for the distance bar, set lims to 0,max for euclid, intersect and 
            # to -1,1 for cosine, pearson
            if distance_bar_range is not None:
                low_db_cap, up_db_cap = distance_bar_range
            else: 
                if metric in [&#39;euclid&#39;, &#39;intersect&#39;]:
                    up_db_cap = round(data[1].iloc[0].max(), 1)
                    low_db_cap = 0
                elif metric == &#39;cosine&#39;:
                    up_db_cap = 1
                    low_db_cap = -1
                elif metric == &#39;pearson&#39;:
                    up_db_cap = 1
                    low_db_cap = round(data[1].iloc[0].min(), 1)
            # for absolute, both distance bar and main bar sacles must be equal
            if not differential:
                if heatmap_range is not None:
                    up_db_cap = up_cap
                    low_db_cap = low_cap
                elif metric == &#39;euclid&#39;:
                    up_cap = up_db_cap = max((up_cap, up_db_cap))
                    low_cap = low_db_cap
                elif metric in [&#39;cosine&#39;, &#39;pearson&#39;]:
                    up_cap = up_db_cap
                    low_cap = low_db_cap

            return low_cap, up_cap, low_db_cap, up_db_cap
        
        # built 2 lists with widths and heights in inches of every axes
        def get_plot_sizes():
            nplts = [4,3]
            fig_widths = [.0001] *(nplts[1] +3)
            fig_widths[0] = samplelabels_space if samplelabels_space else \
                            config.HM_LEFT

            if show_samples_colorbar:
                fig_widths[1] = config.HM_Y_COLORBAR
            fig_widths[2] = config.HM_SQUARE_SIZE * data[0].shape[1]
            if heatmap_width:
                fig_widths[2] *= heatmap_width
            if cluster_samples and show_samples_dendrogram:
                fig_widths[3] = config.HM_Y_DENDROGRAM
            fig_widths[4] = config.HM_WSPACE * (nplts[1]-1)
            fig_widths[5] = config.HM_RIGHT

            fig_heights = [.0001] *(nplts[0] +3)
            fig_heights[0] = config.HM_TOP
            if cluster_targets and not hide_targets_dendrogram:
                fig_heights[1] = config.HM_X_DENDROGRAM
            if not hide_distance_bar:
                fig_heights[2] = config.HM_DISTANCE_BAR
            fig_heights[3] = config.HM_SQUARE_SIZE * len(samples._names_noctrl)
            if heatmap_height:
                fig_heights[3] *= heatmap_height
            if not hide_targets_colorbar:
                fig_heights[4] = config.HM_X_COLORBAR
            fig_heights[5] = config.HM_HSPACE * (nplts[0]-1)
            fig_heights[6] = targetlabels_space if targetlabels_space else \
                             config.HM_BOTTOM

            return nplts, fig_widths, fig_heights

        # draw plot
        def do_plot():
            width, height = sum(fig_widths), sum(fig_heights)
            fig, axes = util._init_figure(fig_widths, fig_heights, nplts, 
                                       (config.HM_WSPACE, config.HM_HSPACE))
            sim, ctrl_sim = data

            # set plot title
            if title and title not in (&#39;None&#39;, &#39;none&#39;, &#39;False&#39;, &#39;false&#39;, &#39;F&#39;, &#39;f&#39;):
                if title and type(title) is not str:
                    this_t = util._make_title(differential, metric, 
                                              samples.name, self.name)
                else:
                    this_t = title
                if not pivot:
                    fig.suptitle(this_t, y=1- (config.HM_TOP/height)*.7, 
                                 fontsize=config.FONTS)
                else:
                    axes[2, 0].set_ylabel(this_t, labelpad=10)

            # cluster targets/ samples and draw dendrograms
            if cluster_targets:
                at = axes[0, 1] if not hide_targets_dendrogram else axes[0, 0]
                order = util._heatmap_cluster(sim, &#39;top&#39;, at, &#39;columns&#39;)
                sim, ctrl_sim = util._align_indices([sim, ctrl_sim], order)
            if cluster_samples:
                at = axes[2, 2] if show_samples_dendrogram else axes[0, 0]
                order = util._heatmap_cluster(sim, &#39;right&#39;, at, &#39;rows&#39;)
                sim = sim.reindex(order)
            axes[0, 0].set_visible(False)
            
            # draw distance effect bar
            if not hide_distance_bar:
                # set order to order of sorted values in distance bar (ctrl)
                if reorder_to_distance_bar:
                    order = ctrl_sim.iloc[0].sort_values().index
                    sim, ctrl_sim = util._align_indices([sim, ctrl_sim], order)
                # only draw colorbar legend if not absolute
                draw_cb = False if hide_colorbar_legend or not differential else True
                # label of the distance bar on the left
                if metric != &#39;intersect&#39; and not hide_samplelabels:
                    ctrl_lbl = samples._ctrl
                else:
                    ctrl_lbl = &#39;&#39;
                # general metric depended labling
                bar_args = {&#39;cmap&#39;: &#39;afmhot_r&#39;, &#39;vmin&#39;: low_db_cap, &#39;vmax&#39;: up_db_cap}
                if metric == &#39;euclid&#39;:                    
                    cb_lbl = &#39;Base &#39; + config.EUCLID_ABS
                    bar_args.update({&#39;cmap&#39;: &#39;afmhot&#39;})
                elif metric == &#39;cosine&#39;:
                    cb_lbl = &#39;Base &#39; + config.COSINE_ABS
                elif metric == &#39;pearson&#39;:
                    cb_lbl = &#39;Base &#39; + config.PEARSON_ABS
                elif metric == &#39;intersect&#39;:
                    cb_lbl = config.INTERSECT_DIST_BAR
                    bar_args.update({&#39;cmap&#39;: &#39;afmhot&#39;})
                util._plot_distance_bar(axes[1, :2], ctrl_sim,
                                            ctrl_lbl, bar_args, draw_cb, 
                                            cb_lbl, fig, pivot, width, height)

            # setup heatmap x,y axis, including the colorbars
            cols = self.get_colors(sim.columns) if not hide_targets_colorbar \
                   else None
            xlbl = sim.columns
            if specific_target_labels:
                xlbl = [lbl if lbl in specific_target_labels else &#39;&#39; for lbl in xlbl]
            util._setup_heatmap_xy(&#39;x&#39;, axes[3, 1], xlbl, pivot,
                                  hide_targetlabels, targetlabels_size, cols)
                   
            cols = samples.get_colors(sim.index[::-1]) if show_samples_colorbar \
                   else None
            util._setup_heatmap_xy(&#39;y&#39;, axes[2, 0], sim.index[::-1], pivot, 
                                   hide_samplelabels, samplelabels_size, cols)

            ax = axes[2, 1]
            ax.set_yticks(np.arange(0, sim.shape[0]))
            ax.set_xticks(np.arange(0, sim.shape[1]))
            hm_args = {&#39;vmin&#39;: low_cap, &#39;vmax&#39;: up_cap}
            hm_args[&#39;cmap&#39;] = &#39;RdBu_r&#39; if differential else &#39;afmhot_r&#39;
            if metric == &#39;euclid&#39; and differential:
                cb_lbl = config.EUCLID_DIFF
            elif metric == &#39;euclid&#39; and not differential:
                cb_lbl = config.EUCLID_ABS
                hm_args[&#39;cmap&#39;] = &#39;afmhot&#39;
            elif metric == &#39;cosine&#39; and differential:
                cb_lbl = config.COSINE_DIFF
            elif metric == &#39;cosine&#39; and not differential:
                cb_lbl = config.COSINE_ABS
            elif metric == &#39;pearson&#39; and differential:
                cb_lbl = config.PEARSON_DIFF
            elif metric == &#39;pearson&#39; and not differential:
                cb_lbl = config.PEARSON_ABS
            elif metric == &#39;intersect&#39;:
                cb_lbl = config.INTERSECT
            im = ax.imshow(sim.values, aspect=&#39;auto&#39;, **hm_args)
            
            # setup heatmap colorbar legend and draw
            if not hide_colorbar_legend:
                at = (config.CB_LEFT/width, 1- config.CB_TOP/height, 
                      config.CB_WIDTH/width, config.CB_HEIGHT/height)
                cax = fig.add_axes(at)
                cb = ax.figure.colorbar(im, cax=cax, orientation=&#39;horizontal&#39;) 
                
                bar_ticks = [hm_args[&#39;vmin&#39;], hm_args[&#39;vmax&#39;]]
                cb.set_ticks(bar_ticks)
                cb.ax.set_xticklabels(bar_ticks)
                if pivot:
                    cb.ax.tick_params(labelrotation=90)
                cb.ax.set_xlabel(cb_lbl)
                cb.ax.get_xaxis().set_label_position(&#39;top&#39;)

            return fig, axes, (sim, ctrl_sim)

        spacer.info(&#39;\n\n&#39; + log_plot)
        logger.info(&#39;Plot: {} &amp; {}&#39;.format(self.name, samples.name))
        _check_args()
        data = get_data()
        low_cap, up_cap, low_db_cap, up_db_cap = get_caps()

        nplts, fig_widths, fig_heights = get_plot_sizes()
        spacer.info(&#39;&#39;)
        logger.info(&#39;Drawing...&#39;)
        if filename:
            filename, pp = util._open_file(filename)
        fig, axes, data = do_plot()
        if plt_show:
            plt.show()
        if filename:
            util._save_file(fig, filename=filename, pp=pp, close_pp=True)
            logger.info(&#39;Plot saved at {}/{}\n\n&#39;
                        .format(os.path.abspath(os.curdir), filename))
        else:
            plt.close(fig)
        return fig, axes, data
        

    def gene_similarity_heatmap(self,
                                # plot data
                                samples,  
                                metric = None,
                                differential = True,
                                display_genes = &#39;variant&#39;,
                                gene_number = 45,
                                specific_genes = None,
                                custom_target_genelist = None,
                                # data ordering
                                cluster_genes = False,
                                cluster_samples = False,
                                reorder_to_distance_bar = False,
                                # general settings
                                pivot = False,
                                heatmap_width = None,
                                heatmap_height = None,
                                heatmap_range = None,
                                distance_bar_range = None,
                                sum_plot_range = None,
                                genelabels_space = None,
                                genelabels_size = None,
                                samplelabels_size = None,
                                samplelabels_space = None,
                                title = True, 
                                # show/ hide elements 
                                hide_colorbar_legend = False,
                                hide_distance_bar = False,
                                hide_sum_plot = False,
                                hide_genelabels = False,
                                hide_genes_dendrogram = False,
                                show_genes_colorbar = None,
                                hide_samplelabels = False,
                                show_samples_dendrogram = False,
                                show_samples_colorbar = False,
                                # others
                                filename = &#39;gene_similarity_hm&#39;,
                                plt_show = False,
                                **kwargs):
        &#34;&#34;&#34;Plot the single-gene similarities of the samples with the targets 
        in an array of heatmaps.
    
        This function reveals the drivers behind target similarity shifts. 
        Besides various gene extraction options, a genelist can be passed to 
        investigate specific similarity changes. On the right of the 
        heatmap, a bar plot visualizes a summery of the gene values.
        Two different metrics can be picked to assess similarity: 
        &#39;euclid&#39; for expression inputs or &#39;intersect&#39; for comparison based 
        on diff. genes/ marker genes. Differential and absolute gene
        similarity values are available options for investagting the change 
        in similarity. When targets were initiated with down-marker genes,
        a seperate heatmap for each marker gene type is drawn.

        Args:
            =================== Plot data options ===================
            samples (samples): the data to rate similarity for.
            metric (str, optional): the similarity metric to use. Valid 
                options are &#39;euclid&#39;, &#39;intersect&#39;, &#39;cosine&#39;, &#39;pearson&#39;. Defaults 
                to None.&#39;euclid&#39; shows the mean euclidean distance towards the 
                target marker genes expression levels and requires `expression` 
                input for samples and targets. &#39;intersect&#39; will show the overlap 
                between diff. sample genes and target marker genes requiring 
                gene list input. &#39;cosine&#39; will compute the cosine similarity, 
                &#39;pearson&#39; the Pearson correlation coefficient. More details in
                publication. When None, set to &#39;cosine&#39; when expression input 
                was passed, or &#39;intersect&#39; when gene list data was passed.
            differential (bool, optional): plot the differential (change in)
                similarity from the untreated-,/ base-sample, or. the control 
                to other samples. Defaults to True. Requires a control to be 
                passed for the expression-based metrics. Cannot be False for 
                &#39;intersect&#39;-metric.
            display_genes (str, optional): Extract a specific set of 
                marker genes to display for each target. Defaults to &#39;variant&#39;. 
                Valid options are &#39;variant&#39;, &#39;increasing&#39;, &#39;decreasing&#39; when 
                differential True, and &#39;variant&#39;, &#39;distant&#39;, &#39;similar&#39; for 
                differential False. To identify sample specific effects, these 
                metrics will sort according to outlaying sample values rather 
                then overall high/ low/ increasing etc. values. This is one of 
                the 3 gene selection options to choose from.
            gene_number (int, optional): The number of genes to plot for the 
                &#39;display_genes&#39; option. Defaults to 45. This option is 
                ignored for the two other gene selection options 
                &#39;specific_genes&#39; and &#39;custom_target_genelist&#39;. 
            specific_genes (list, optional): Specify the marker genes to 
                display in a list of gene names. Defaults to None. A gene 
                from this list is only displayed if it is a marker gene of 
                the specifc target and detected in the samples. This option can 
                be used idependently or in combination with &#39;display_genes&#39; for 
                adding specific genes of interest to the extracted ones. Genes 
                are annotated referencing enseble v.96.
            custom_target_genelist (list, optional): Specify a custom list 
                of gene names to display similarity for. Defaults to None. 
                Currently this option is only implemented for the &#39;euclid&#39; 
                similarity metric. The passed genelist will be used for all 
                targets. In contrast to &#39;specific_genes&#39;, the genes only need to 
                be detected in the targets instead of qualifying as specific 
                target marker genes. Still, genes need to be detected in the 
                samples. Genes are annotated referencing enseble v.96.
            
            =================== data ordering options ===================
            cluster_genes (bool, optional): cluster genes using the 
                euclidean distance. Defaults to False.
            cluster_samples (bool, optional): cluster samples using the 
                euclidean distance. Defaults to False.
            reorder_to_distance_bar (bool, optional): reorder the genes
                from lowest to highest base distance. Defaults to False. 
                Cannot be True when  &#39;cluster_genes&#39; is True aswell.
                For details, check the &#39;hide_distance_bar&#39; argument. 

            =================== general visual options ===================
            pivot (bool, optional): pivot the heatmap by 90 degrees. Defaults 
                to False. Useful for fitting the heatmap on a canvas. 
            heatmap_width (float, optional): multiplier to stretch/ squeeze 
                the heatmap squares in x direction. Defaults to None. For 
                pivot = True this paramter controls the height. 
                Useful for very low or high number of genes. 
            heatmap_height (float, optional): multiplier to stretch/ squeeze 
                the heatmap squares in y direction. Defaults to None. For 
                pivot = True this paramter controls the width.
                Useful for very low or high number of samples.
            distance_bar_range (list, optional): Define the range of values
                that form the colormap for the distance bar. Defaults to
                None. The list is interpreted as, [lower_limit, upper_limit]. 
                When None, the edges are defined to cover 90% of occuring values 
                ignoring outlayers. 
            sum_plot_range (list, optional): Define the lower- and upper 
                x-limits for the summary plot. Defaults to None. The list is 
                interpreted as, [lower_limit, upper_limit]. When None, the 
                x-limits are defined by adding 15% to the minimum and maximum
                values. 
            genelabels_space (float, optional): define the size in inches
                to reserve for gene labels, here, the white space on the
                bottom. Defaults to None. When None, refer to the values set in 
                config.HM_BOTTOM.
            samplelabels_space (float, optional): define the size in inches
                to reserve for sample labels, here, the white space on the
                left. Defaults to None. When None, refer to the value set in 
                config.HM_LEFT.
            genelabels_size (float, optional): multiplier for adjusting gene 
                label size. Defaults to None. Useful for very high or low 
                number of genes.
            samplelabels_size (float, optional): multiplier for adjusting 
                sample label size. Defaults to None. Useful for very high or low 
                number of samples.
            title (bool, str, optional): the plot title to set. Defaults to 
                True. For True, infer the title based on plot data inputs and 
                targets/ samples name attribute. Text input will be set as 
                the general title, False hides the title. A list of str will be
                set according to the list of plots.
            kwargs: modify the constants defined in config. This is used as an 
                advanced adjustment of plot element sizes and the minimum 
                required marker genes detection proportion. The heatmaps may be
                adjusted by the following paramters: DROP_TARGET_DETEC_THR,
                HM_LEFT, HM_TOP, HM_RIGHT, HM_BOTTOM, HM_WSPACE, 
                HM_HSPACE, HM_Y_COLORBAR, HM_X_COLORBAR, HM_DISTANCE_BAR, 
                HM_Y_DENDROGRAM, HM_X_DENDROGRAM, HM_SQUARE_SIZE, 
                G_HM_SUMPLOT_SIZEG_HM_UPDOWN_SPACE_SIZE, CB_LEFT, 
                CB_LEFT_SEC, CB_TOP, CB_WIDTH, 
                CB_HEIGHT.
            
            =================== hide/show plot elements ===================
            hide_colorbar_legend (bool, optional): Do not plot the colorbar 
                legend. Defaults to False. Applies for all colorbar_legends.
            hide_distance_bar (bool, optional): Do not plot the distance 
                bar on top of the heatmap. Defaults to False. When True, the 
                control will appear in the main heatmap. For the expression-
                based metrics, this bar visualizes the absolute similarity of 
                the control with the targets. For the &#39;intersect&#39; metric, the 
                number of target marker genes is shown. Defaults to False.
            hide_sum_plot (bool, optional): Do not generate the summary plot on
                the right visualizing the samples genes. Defualts to False.
                This plot shows the summarized similarity of all genes. It 
                computes like the target similarty, but limited to the displayed
                genes.
            hide_genelabels (bool, optional): Do not plot the gene 
                labels at the bottom. Defaults to False.
            hide_genes_dendrogram (bool, optional): Do not plot the 
                genes dendrogram from clustering. Defaults to False. 
                Requires &#39;cluster_genes&#39; to be True. 
            show_genes_colorbar (dict, bool, optional): Plot a genes colorbar on 
                the bottom of the heatmap. Defaults to None. A dictionary 
                should map gene names to colors. Mappings for genes not 
                displayed in the plot are ignored. The color for M=missing gene 
                keys is set to white. When, True and `specifc_genes` passed,
                the passed genes will be set to config.colors[1] (green). 
            hide_samplelabels (bool, optional): Do not plot the sample 
                labels at the left. Defaults to False.
            show_samples_dendrogram (bool, optional): Plot the samples 
                dendrogram from clustering. Defaults to False. Requires 
                &#39;cluster_samples&#39; to be True.
            show_samples_colorbar (bool, optional): Plot the samples
                colorbar on the left of the heatmap. Defaults to False. 
                When colors are not set for the targets using the 
                set_colors() function, colors are set to white. 

            =================== others ===================
            filename (str, optional): the filename for saving the figure.
                Defaults to &#39;gene_similarity_hm.pdf&#39;. Supported filename 
                endings are .png and .pdf. If filename does not end with 
                these, the filetype is retrieved from conifg.SAVE_FORMAT.
                If None, the plot is not saved.
            plt_show (bool, optional): directly show each created plot in a new
                window. Defaults to False.
        &#34;&#34;&#34;
        # check user input for errors and incompatibilities
        def _check_args():
            nonlocal metric
            nonlocal differential
            nonlocal display_genes
            nonlocal specific_genes
            nonlocal custom_target_genelist

            nonlocal hide_distance_bar
            nonlocal reorder_to_distance_bar
            nonlocal cluster_genes
            nonlocal show_genes_colorbar
            nonlocal distance_bar_range

            # check general basic input requirements
            r = util._check_args(self, samples, metric, differential, 
                                 hide_distance_bar, reorder_to_distance_bar, 
                                 distance_bar_range, cluster_genes)
            if r[0] == &#39;cosine&#39;:
                # default for per gene cannot be cosine, change to euclid here
                metric = &#39;euclid&#39;
            _, differential, hide_distance_bar, reorder_to_distance_bar, \
            distance_bar_range, cluster_genes, _ = r

            # check main data input
            if self._species not in [&#39;human&#39;, &#39;mouse&#39;]:
                logger.info(&#39;&#39;)
                logger.error(&#39;Invalid input for species: `{}`. Valid are `mouse` &#39;
                             &#39;and `human`. Initate targets with these species &#39; 
                             &#39;to use this function.&#39;.format(self._species))
                sys.exit(1)
            if metric == &#39;intersect&#39; and not hide_distance_bar:
                hide_distance_bar = True
                logger.warning(&#39;For the intersect metric, there is no distance&#39;
                               &#39;bar. `hide_distance_bar` was set to True.&#39;)
            if custom_target_genelist is not None and metric == &#39;intersect&#39;:
                logger.error(&#39;The `custom_target_genelist` option is &#39;
                             &#39;currentily not implemented for the similarity &#39;
                             &#39;metric `intersect`. Please choose an alternative &#39;
                             &#39;gene selection option.&#39;)
                sys.exit(1)
            if custom_target_genelist is not None and display_genes:
                display_genes = None
                logger.info(&#39;Both `display_genes` and &#39;
                            &#39;`custom_target_genelist` were passed. &#39;
                            &#39;`display_genes` will be ignored.&#39;)
            if display_genes:
                val = [&#39;variant&#39;, &#39;increasing&#39;, &#39;decreasing&#39;]
                if not differential:
                     val = [&#39;variant&#39;, &#39;distant&#39;, &#39;similar&#39;]
                if display_genes not in val:
                    logger.error(&#39;The passed value for display_genes: `{}` is &#39;
                                 &#39;invalid. Valid options when `differential` is&#39;
                                 &#39; {} are {}.&#39;
                                 .format(display_genes, differential, val))
                    sys.exit(1)
            elif custom_target_genelist is None and specific_genes is None:
                logger.error(&#39;None of `display_genes`, `specific_genes` or &#39;
                             &#39;`custom_target_genelist` were passed&#39;)
                sys.exit(1)
            elif custom_target_genelist is not None and specific_genes is not None:
                specific_genes = None
                msg = (&#39;Both `specific_genes` and `custom_target_genelist` were&#39;
                       &#39; passed. `specific_genes` will be ignored.&#39;)
                logger.info(msg)
            config._update_consts(kwargs)
            
            # modify arguments for convneience 
            if show_genes_colorbar == True:
                if specific_genes:
                    show_genes_colorbar = dict.fromkeys(specific_genes, 
                                                        config.colors[1])
                else:
                    show_genes_colorbar = None

            # get a list of generally valid annotated genes
            genes = pd.DataFrame({&#39;name&#39;: util.annotate(self._mgs, self._species), 
                                  &#39;ensg&#39;: self._mgs })
            if specific_genes is not None or custom_target_genelist is not None:
                # for gene input check if genes are detected in the target data
                if specific_genes is not None:
                    inp_gl = pd.Index(specific_genes).drop_duplicates()
                    val_gl = pd.Index(genes.name.values)
                    isin = &#39;marker genes&#39;
                elif custom_target_genelist is not None:
                    inp_gl = pd.Index(custom_target_genelist).drop_duplicates()
                    val_gl_ensg = self._detec_genes.intersection(samples._detec_genes)
                    isin = &#39;detected genes&#39;
                    val_gl = pd.Index(util.annotate(val_gl_ensg, self._species))
                
                inv = [g for g in inp_gl if g not in val_gl]
                inp_gl = inp_gl.drop(inv) 
                if inv:
                    logger.warning(&#39;{} ({}/{}) are not {} in any of the targets&#39;
                                   &#39; or are not detected in the samples. These &#39;
                                   &#39;genes will not be included.&#39;.format(inv,
                                    len(inv), len(inv)+len(inp_gl), isin))
                    if len(inv) == (len(inv)+len(inp_gl)):
                        sys.exit(1)
                # update passed list
                if specific_genes is not None:
                    specific_genes = inp_gl
                elif custom_target_genelist is not None:
                    genes = util.get_ensgs(inp_gl, self._species)
                    # duplicated indicies are painful in pandas...
                    if genes.name.duplicated().any():
                        val_gl = pd.Index(genes.ensg).intersection(val_gl_ensg)
                        genes = genes.reindex(genes.index[genes.ensg.isin(val_gl)])
                        if genes.name.tolist() != inp_gl.tolist():
                            try:
                                genes = genes.set_index(&#39;name&#39;).reindex(inp_gl)
                                genes.reset_index(inplace=True)
                                genes = genes.rename({&#39;index&#39;: &#39;name&#39;}, axis=1)
                            except Exception:
                                logger.warning(&#39;Input gene order could not be&#39;
                                               &#39;kept because of duplicate &#39;
                                               &#39;gene name issues.&#39;)
            logger.info(&#39;Arguments passed. Getting data now ...&#39;)
            return genes                   

        # get the specific similarity data and pick out the genes to display
        def get_data():
            # init a new target where all genes are marker genes of all targets
            if custom_target_genelist:
                nonlocal self
                expr = self._expr.reindex(genes.ensg).copy()
                args = {&#39;expression&#39;: expr}
                self = targets(name=&#39;custom genelist&#39;, ignore_down_mgs=True, 
                               log=False, **args)
            sim, ctrl_sim = self._get_similarity(samples, metric, &#39;gene_sim&#39;,
                                                 differential=differential,
                                                 drop_ctrl= not hide_distance_bar)

            # init mutable nested dict with target and markegene type keys
            data = dict((trg, dict((mgt, None) for mgt in self._mg_types))
                        for trg in self.names)
            # select genes, form the 3 data elements per-gene similarity (heatmap), 
            # ctrl_sim (distance_bar), target similarity (sumplot)
            def sel_genes(gene_sim, genes):
                mgt = gene_sim.columns[0][0]
                trg = gene_sim.columns[0][1]
                get_genes = pd.Index([])
                gene_sim.dropna(inplace=True)
                
                if display_genes:
                    # sort similarities based on passed metric, slice to gene number
                    if display_genes == &#39;variant&#39;:
                        idx = gene_sim.var(1).sort_values(ascending=False).index
                    elif metric == &#39;euclid&#39;:
                        if display_genes in [&#39;increasing&#39;, &#39;distant&#39;]:
                            idx = gene_sim.max(1).sort_values(ascending=False).index
                        elif display_genes in [&#39;decreasing&#39;, &#39;similar&#39;]:
                            idx = gene_sim.min(1).sort_values().index       
                    elif metric == &#39;intersect&#39;:
                        if display_genes.startswith(&#39;in&#39;) and mgt == &#39;down&#39; or \
                        display_genes.startswith(&#39;de&#39;) and mgt == &#39;up&#39;:
                            asc = True
                        elif display_genes.startswith(&#39;in&#39;) and mgt == &#39;up&#39; or \
                        display_genes.startswith(&#39;de&#39;) and mgt == &#39;down&#39;:
                            asc = False
                        idx = gene_sim.sum(1).sort_values(ascending=asc).index
                    get_genes = idx[:gene_number]
                    
                if specific_genes is not None:
                    # check if passed genelist in target marker genes add them 
                    # if not already in 
                    inp_ensg = util.get_ensgs(specific_genes, self._species).ensg
                    not_mg = filter(lambda ie: ie not in gene_sim.index, inp_ensg)
                    inv = genes.set_index(&#39;ensg&#39;).reindex(not_mg).name
                    if not inv.empty:
                        logger.info(&#39;{} not included: not marker genes of `&#39;
                                    &#39;{}-{}`&#39;.format(inv.tolist(), mgt, trg))
                    add = lambda ie: not (ie in get_genes or ie in inv)
                    add_genes = pd.Index(filter(add, inp_ensg))
                    if not add_genes.empty:
                        get_genes = get_genes.append(add_genes)
                elif custom_target_genelist:
                    get_genes = genes.ensg
                
                if get_genes.empty:
                    logger.error(&#39;No genes were picked for {}-{}. Check input.&#39;
                                 .format(mgt, trg))
                    sys.exit(1)
                # index per gene similarity to final gene list
                # per gene similarity for heatmap
                gs = gene_sim.reindex(get_genes)
                # target similarity for heatmap
                ts = gs.mean()

                # control similarity for distance bar
                if metric == &#39;euclid&#39; and not hide_distance_bar:
                    cs = ctrl_sim.loc[get_genes, (mgt, trg, samples._ctrl)].to_frame().T
                else:
                    cs = None
                data[trg][mgt] = (gs.T, cs, ts)
            
            # iterate target+marker gene type
            sim.groupby(axis=1, level=(0,1), sort=False).apply(sel_genes, genes)
            return data

        # get data limits across all targets and marker gene types to plot with 
        # one consistent heatmap range 
        def get_caps():
             # unpack nested dict into the 3 plot data elements       
            data_l = [e for dat in list(data.values())
                      for d in list(dat.values()) for e in d]
            # gene sim (heatmap), ctrl sim (distance bar) target sim (sum plot)
            gs, cs, ts = [data_l[get::3] for get in (0,1,2)]
            
             # get number of genes per plot
            n_genes = [ts.shape[1] for ts in gs]
            if self._down_mgs:
                n_genes = [max(gs[i].shape[1], gs[i+1].shape[1]) 
                           for i in range(0, len(gs), 2)]

             # get sum plot limits
            if sum_plot_range is not None:
                ts_lim = sum_plot_range
            else:
                ts_min = min([sim.min() for sim in ts])
                ts_max = max([sim.max() for sim in ts])
                ts_lim = [ts_min -abs(ts_min*.15), ts_max +abs(ts_max*.15)]
                # make sure 0 is included
                if differential or True:
                    if ts_lim[0]&gt;=0 and ts_lim[1]&gt;=0:
                        ts_lim[ts_lim.index(min(ts_lim))] = 0
                    elif ts_lim[0]&lt;=0 and ts_lim[1]&lt;=0:
                        ts_lim[ts_lim.index(max(ts_lim))] = 0
            
            # get per gene heatmap range (only required for euclid)
            if metric == &#39;euclid&#39;:
                if heatmap_range is not None:
                    low_cap, up_cap = heatmap_range
                else:
                    mini = [sim.min().sort_values()[int(sim.shape[1]*.05)] for sim in gs]
                    maxi = [sim.max().sort_values()[int(sim.shape[1]*.95)] for sim in gs]
                    up_cap = round(max((abs(min(mini)), abs(max(maxi)))), 1)
                    low_cap = -up_cap if differential else 0
                
                # get distance bar range
                if not hide_distance_bar:
                    if distance_bar_range is not None:
                        low_db_cap, up_db_cap = distance_bar_range
                    else: 
                        up_db_cap = round(max([sim.iloc[0].sort_values()[int(sim.shape[1]*.95)]
                                            for sim in cs]), 1)
                        low_db_cap = 0

                    # make sure heatmap and distance bar ranges align
                    if not differential:
                        if heatmap_range is not None:
                            up_db_cap = up_cap
                            low_db_cap = low_cap
                        else:
                            up_cap = up_db_cap = max((up_cap, up_db_cap))
                            low_cap = low_db_cap
                else:
                    up_db_cap = low_db_cap = None
                return up_cap, low_cap, up_db_cap, low_db_cap, ts_lim, n_genes
            # for the intersect mertic, the values can only be -1, 0 and 1
            elif metric == &#39;intersect&#39;:
                return 1, -1, None, None, ts_lim, n_genes
        
        # built 2 lists with widths and heights in inches of every axes
        def get_plot_sizes():
            nplts = [4, 4]
            # default size of an exes is 0
            fig_widths = [.0001] *(nplts[1] +3)
            # based on parameters and config constants, set all sizes
            fig_widths[0] = samplelabels_space if samplelabels_space \
                            else config.HM_LEFT
            if show_samples_colorbar:
                fig_widths[1] = config.HM_Y_COLORBAR
            # heatmap width varies across plots, a nested list stores widths
            fig_widths[2] = [n_gs*config.HM_SQUARE_SIZE for n_gs in n_genes]
            if heatmap_width:
                fig_widths[2] = [heatmap_width*f_ws2 for f_ws2 in fig_widths[2]]
            if cluster_samples and show_samples_dendrogram:
                fig_widths[3] = config.HM_Y_DENDROGRAM
            if not hide_sum_plot:
                fig_widths[4] = config.G_HM_SUMPLOT_SIZE
            fig_widths[5] = config.HM_WSPACE * (nplts[1]-1)
            fig_widths[6] = config.HM_RIGHT

            fig_heights = [.0001] *(nplts[0] +3)
            fig_heights[0] = config.HM_TOP
            if cluster_genes and not hide_genes_dendrogram:
                fig_heights[1] = config.HM_X_DENDROGRAM
            if not hide_distance_bar:
                fig_heights[2] = config.HM_DISTANCE_BAR 
            fig_heights[3] = config.HM_SQUARE_SIZE *len(samples._names_noctrl) 
            if heatmap_height:
                fig_heights[3] *= heatmap_height
            if show_genes_colorbar:
                fig_heights[4] = config.HM_X_COLORBAR
            fig_heights[5] = config.HM_HSPACE * (nplts[0]-1)
            fig_heights[6] = genelabels_space if genelabels_space else \
                             config.HM_BOTTOM

            # duplicate height sizes and insert a spacer axis with size of top
            if self._down_mgs:
                nplts[0] = nplts[0] *2 +1
                hs = fig_heights
                ins = [config.G_HM_UPDOWN_SPACE_SIZE]
                fig_heights = hs[:-2] + ins + hs[1:-2] + hs[-2:]
                fig_heights[-2] = config.HM_HSPACE * (nplts[0]-1)
            return nplts, fig_widths, fig_heights

        # draw plot
        def do_plot(i):
            # get final width list for specific number of genes in plot
            this_fig_widths = fig_widths[:2] +[fig_widths[2][i]] +fig_widths[3:]
            width, height = sum(this_fig_widths), sum(fig_heights)
            fig, axes = util._init_figure(this_fig_widths, fig_heights, nplts, 
                                          (config.HM_WSPACE, config.HM_HSPACE))
            if self._down_mgs:
                [ax.set_visible(False) for ax in axes[4, :]]

            # set plot title
            if title and title not in (&#39;None&#39;, &#39;none&#39;, &#39;False&#39;, &#39;false&#39;, &#39;F&#39;, &#39;f&#39;):
                if title == True:
                    this_t = util._make_title(differential, metric,
                                              samples.name, t_name, 
                                              postf=&#39;per gene &#39;)
                    if display_genes:
                        this_t += &#39; - most similarity {} genes&#39;.format(display_genes) 
                    elif specific_genes is not None:
                        this_t += &#39; - list of specific marker genes&#39;
                    elif custom_target_genelist is not None:
                        this_t += &#39; - custom list of genes&#39;
                    
                elif title and isinstance(title, (list, tuple)):
                    this_t = title[i]
                else:
                    this_t = title
                if not pivot:
                    fig.suptitle(this_t, y=1- (config.HM_TOP/height)*.7,
                                 fontsize=config.FONTS)
                else:
                    row = 2 if not self._down_mgs else 7
                    axes[row, 0].set_ylabel(this_t, labelpad=10)
                
            # iterate over up and down plot-halfs
            for mgt, r in zip(self._mg_types, (0, 5)):
                sim, ctrl_sim, sim_trg = dat[mgt]

                # cluster genes/ samples and draw dendrograms
                if cluster_genes:
                    at = axes[r, 1] if not hide_genes_dendrogram else axes[r, 0]
                    order = util._heatmap_cluster(sim, &#39;top&#39;, at, &#39;columns&#39;)
                    sim, ctrl_sim = util._align_indices([sim, ctrl_sim], order)
                if cluster_samples:
                    at = axes[2+r, 2] if show_samples_dendrogram else axes[r, 0]
                    order = util._heatmap_cluster(sim, &#39;right&#39;, at, &#39;rows&#39;)
                    sim, sim_trg = util._align_indices([sim, sim_trg], order, 0)
                axes[r, 0].set_visible(False)

                # draw the distance bar 
                if not hide_distance_bar and metric == &#39;euclid&#39;:
                    # set order to order of sorted values in distance bar (ctrl)
                    if reorder_to_distance_bar:
                        order = ctrl_sim.iloc[0].sort_values().index
                        sim, ctrl_sim = util._align_indices([sim, ctrl_sim], order)
                        
                    bar_args = {&#39;vmin&#39;: low_db_cap, &#39;vmax&#39;: up_db_cap,
                                &#39;cmap&#39;: &#39;afmhot&#39;}
                    cb_lbl = config.EUCLID_ABS
                    # only draw colorbar legend if not absolute
                    if not hide_colorbar_legend and differential and mgt==&#39;up&#39;:
                        draw_cb = True
                    else:
                        draw_cb = False
                    # label of the distance bar on the left
                    ctrl_lbl = samples._ctrl if not hide_samplelabels else &#39;&#39;
                    util._plot_distance_bar(axes[1+r, :2], ctrl_sim, 
                                                  ctrl_lbl, bar_args, draw_cb, 
                                                  cb_lbl, fig, pivot, width, 
                                                  height)

                # setup heatmap x axis, including the colorbar
                xlbl = genes.set_index(&#39;ensg&#39;).reindex(sim.columns).name.values
                if show_genes_colorbar:
                    default = show_genes_colorbar.get(&#39;default&#39;, &#39;w&#39;) 
                    cols = [show_genes_colorbar.get(g, default) for g in xlbl]
                    cols = [c if is_color_like(c) else default for c in cols]
                else:
                    cols = None
                util._setup_heatmap_xy(&#39;x&#39;, axes[3+r, 1], xlbl, pivot,
                                      hide_genelabels, genelabels_size, cols) 

                # setup heatmap y axis, including the colorbar
                ylbl = sim.index.unique(2)[::-1]
                cols = samples.get_colors(ylbl) if show_samples_colorbar else \
                       None
                util._setup_heatmap_xy(&#39;y&#39;, axes[2+r, 0], ylbl, pivot, 
                                      hide_samplelabels, samplelabels_size, cols)
                if self._down_mgs:
                    tit = &#39;{} marker genes&#39;.format(mgt)
                    pad = 13 if not hide_distance_bar else 4
                    loc = &#39;right&#39; if not pivot else &#39;left&#39;
                    axes[2+r, 0].set_title(tit, loc=loc, fontweight=&#39;bold&#39;, 
                                           fontsize=config.FONTS, pad=pad)
                
                # draw summary plot on the right
                if not hide_sum_plot:
                    # general setup
                    ax = axes[2+r, 3]
                    ax.tick_params(labelbottom=True, bottom=True)
                    if pivot:
                        ax.tick_params(labelrotation=90)
                         
                    axes[3+r, 3].set_visible(False)
                    axes[1+r, 3].set_visible(False)
                    ax.set_axisbelow(True)
                    ax.xaxis.grid(alpha=0.8, linestyle=&#39;dashed&#39;)

                    # setup y axes
                    nsmps = sim_trg.shape[0]
                    ax.set_ylim(-.1, nsmps+.1)
                    yts = np.arange(nsmps-.5, -.5, -1)
                    ax.set_yticks(yts)

                    # setup x axes
                    ax.set_xlim(ts_lim)
                    if metric == &#39;euclid&#39; and differential:
                        lbl = config.EUCLID_DIFF
                    elif metric == &#39;euclid&#39; and not differential:
                        lbl = config.EUCLID_ABS
                        if not hide_distance_bar:
                            base = ctrl_sim.mean(1)
                            ax.vlines(base, 0, nsmps)
                            lbl += &#39;\n(line = base)&#39;
                    elif metric == &#39;intersect&#39;:
                        lbl = config.INTERSECT
                    if not pivot:
                        if (mgt==&#39;up&#39; and not self._down_mgs) or \
                        (mgt==&#39;down&#39; and self._down_mgs):
                            ax.set_xlabel(lbl)
                    else:
                        ax.get_yaxis().set_label_position(&#39;right&#39;)
                        ax.set_ylabel(lbl, rotation=90, labelpad=5)
                        
                    # if metric == &#39;euclid&#39;:
                    blue = config.colors[18] 
                    red = config.colors[14]
                    cols = [red if v &gt;0 else blue for v in sim_trg.values]
                    ax.barh(y=yts, width=sim_trg, color=cols)

                # draw heatmap
                ax = axes[2+r, 1]
                ax.set_yticks(np.arange(0, sim.shape[0]))
                ax.set_xticks(np.arange(0, sim.shape[1]))

                hm_args = {&#39;vmin&#39;: low_cap, &#39;vmax&#39;: up_cap}
                if metric == &#39;euclid&#39; and differential:
                        hm_args.update({&#39;cmap&#39;: &#39;RdBu_r&#39;})
                        cb_lbl = config.EUCLID_DIFF
                if metric == &#39;euclid&#39; and not differential:
                        hm_args.update({&#39;cmap&#39;: &#39;afmhot&#39;})
                        cb_lbl = config.EUCLID_ABS
                elif metric == &#39;intersect&#39;:
                        hm_args.update({&#39;cmap&#39;: config.RdBu_bin})
                        cb_lbl = config.INTERSECT_GENES
                im = ax.imshow(sim.values, aspect=&#39;auto&#39;, **hm_args)

                # setup heatmap colorbar legend and draw
                if mgt == &#39;up&#39; and not hide_colorbar_legend:    
                    # add a new axis for the colorbar
                    at = (config.CB_LEFT/width, 1- config.CB_TOP/height, 
                          config.CB_WIDTH/width, config.CB_HEIGHT/height)
                    cax = fig.add_axes(at)
                    cb = ax.figure.colorbar(im, cax=cax, orientation=&#39;horizontal&#39;) 
                    cb.ax.set_xlabel(cb_lbl)
                    cb.ax.get_xaxis().set_label_position(&#39;top&#39;)
                    bar_ticks = [hm_args[&#39;vmin&#39;], hm_args[&#39;vmax&#39;]]
                    cb.set_ticks(bar_ticks)                
                    if metric == &#39;intersect&#39;:
                        bar_ticks = (&#39;mismatch&#39;, &#39;match&#39;)
                    cb.ax.set_xticklabels(bar_ticks)
                    if pivot:
                        cb.ax.tick_params(labelrotation=90)
                dat[mgt] = sim, ctrl_sim, sim_trg
            return fig, axes, dat
            
        spacer.info(&#39;\n\n&#39; + log_plot)
        logger.info(&#39;Plot: {} &amp; {}&#39;.format(self.name, samples.name))
        genes = _check_args()
        data = get_data()
        up_cap, low_cap, up_db_cap, low_db_cap, ts_lim, n_genes = get_caps()

        nplts, fig_widths, fig_heights = get_plot_sizes()
        spacer.info(&#39;&#39;)
        logger.info(&#39;Drawing...&#39;)
        if filename:
            filename, pp = util._open_file(filename)
            ftype = filename[-4:]
        ret = {}
        for i, (t_name, dat) in enumerate(data.items()):
            fig, axes, dat = do_plot(i)
            spacer.info(&#39;{}/{} --- {}&#39;.format(i+1, len(data), t_name))
            if plt_show:
                plt.show()
            ret.update({t_name: (fig, axes, dat)})
            if filename:
                this_png_fn = &#39;{}_{}{}&#39;.format(filename[:-4], t_name, ftype)
                util._save_file(fig, filename=this_png_fn, pp=pp)
        if filename:
            if pp:
                pp.close()
            logger.info(&#39;Plots saved at {}/{}\n\n&#39;
                        .format(os.path.abspath(os.curdir), filename))
        return ret 

    def ranked_similarity_barplot(self,
                                  # plot data
                                  samples,
                                  metric = None, 
                                  differential = True,
                                  display_markergenes = &#39;mean&#39;,
                                  n_targets = 16,
                                  display_negative = False,
                                  # data ordering
                                  rank_samples = False,
                                  # general settings
                                  pivot = False,
                                  xlim_range = None,
                                  targetlabels_space = None,
                                  targetlabels_size = None,
                                  colored_bars = False,
                                  spines = False,
                                  title = True,
                                  # show/ hide elements
                                  hide_targetlabels = False,
                                  hide_colorbar = False,
                                  hide_base_lines = False,
                                  # others
                                  filename = &#39;ranked_similarity_bp&#39;,
                                  plt_show = False,
                                  **kwargs):
        &#34;&#34;&#34;Plot the ranked similarity of the samples with the targets in a 
        barplot

            Sort the similarity values of the samples and targets to identify
            the dominating effects in the samples. Two different metrics can be 
            picked to assess similarity: &#39;euclid&#39; for expression inputs or 
            &#39;intersect&#39; for comparison based on diff. genes/ marker genes.
            Differential and absolute similarity values are available 
            options for investagting the change in similarity.

        Args:
            =================== Plot data options ===================
            samples (samples): the data to rank similariity for.
            metric (str, optional): the similarity metric to use. Valid 
                options are &#39;euclid&#39;, &#39;intersect&#39;, &#39;cosine&#39;, &#39;pearson&#39;. Defaults 
                to None.&#39;euclid&#39; shows the mean euclidean distance towards the 
                target marker genes expression levels and requires `expression` 
                input for samples and targets. &#39;intersect&#39; will show the overlap 
                between diff. sample genes and target marker genes requiring 
                gene list input. &#39;cosine&#39; will compute the cosine similarity, 
                &#39;pearson&#39; the Pearson correlation coefficient. More details in
                publication. When None, set to &#39;cosine&#39; when expression input 
                was passed, or &#39;intersect&#39; when gene list data was passed.
            differential (bool, optional): plot the differential (change in)
                similarity from the untreated-,/ base-sample, or. the control 
                to other samples. Defaults to True. Requires a control to be 
                passed for the expression-based metrics. Cannot be False for 
                &#39;intersect&#39;-metric.
            display_markergenes (str, optional): specify the group of 
                marker genes to display similarity for. Defaults to &#39;mean&#39;. 
                Valid options are &#39;mean&#39;, &#39;up&#39;, &#39;down&#39;. Relevent when targets 
                are initiated with down-marker genes.
            n_targets (int, optional): the number of targets to display in each
                plot. Defaults to 16. 
            display_negative (bool, optional): display the most negative values 
                on the bottom half of the bar plot. Defaults to False. 

            =================== data ordering options ===================
            rank_samples (bool, optional): Rank the samples based on their most 
                positive value and generate the barplots in the same order. 
                Defaults to False. When False, use the default samples order.
            
            =================== general visual options ===================
            pivot (bool, optional): pivot the barplot by 90 degrees. 
                Defaults to False. Useful for fitting the barplot on a canvas. 
            xlim_range (list, optional): Define the lower- and upper 
                x-limits for the barplot. Defaults to None. The list is 
                interpreted as, [lower_limit, upper_limit]. When None, the 
                x-limits are defined by adding 15% to the minimum and maximum
                values. 
            targetlabels_space (float, optional): define the size in inches
                to reserve for target labels, here, the white space on the
                left. Defaults to None. When None, refer to the value set in 
                config.BP_LEFT.
            targetlabels_size (float, optional): multiplier for adjusting 
                target label size. Defaults to None. Useful for very high or low 
                number of targets.
            colored_bars (bool, optional): colorize negative values in blue, 
                positive ones in red. Defaults to False.
            spines (bool, optional): in addition to the bottom and left spines,
                plot the top and right ones. Defaults to False.
            title (bool, str, list optional): the plot title to set. Defaults to 
                True. For True, infer the title based on plot data inputs and 
                targets/ samples name attribute. Text input will be set as 
                the general title, False hides the title. A list of str will be
                set according to the list of plots.
            kwargs: modify the constants defined in config. This is used as an 
                advanced adjustment of plot element sizes and the minimum 
                required marker genes detection proportion. The barplots may be
                adjusted by the following paramters: DROP_TARGET_DETEC_THR,
                BP_LEFT, BP_TOP, BP_RIGHT, BP_BOTTOM, BP_Y_COLORBAR, 
                BP_BARSPACE, BP_BARWIDTH_SIZE.

            =================== hide/show plot elements ===================
            hide_targetlabels (bool, optional): Do not plot the target labels 
                at the left. Defaults to False.
            hide_colorbar (bool, optional): Do not plot the targets colorbar on 
                the left of the barplot. Defaults to False. 
            hide_base_lines (bool, optional): Do not show the lines marking 
                the absolute simialrity of the control, i.e. the base line. 
            
            =================== others ===================
            filename (str, optional): the filename for saving the figure.
                Defaults to &#39;ranked_similarity_bp.png&#39;. Supported filename 
                endings are .png and .pdf. If filename does not end with 
                these, the filetype is retrieved from conifg.SAVE_FORMAT.
                If None, the plot is not saved.
            plt_show (bool, optional): directly show each created plot in a new
                window. Defaults to False.
            
        &#34;&#34;&#34;
        # check user input for errors and incompatibilities around `metric` arg
        def _check_args():
            nonlocal metric
            nonlocal differential
            nonlocal n_targets
            nonlocal display_markergenes

            # check general basic input requirements
            r = util._check_args(self, samples, metric, differential,  
                                 display_markergenes=display_markergenes)
            metric, differential, _, _, _, _, display_markergenes = r
            if not n_targets or n_targets &gt; len(self):
                n_targets = len(self)
                logger.warning(&#39;The number of targets `n_targets` was None or &#39;
                               &#39;greater the length of the targets. Set to all &#39;
                               &#39;target elements ({}).&#39;.format(len(self)))
            config._update_consts(kwargs)            
            logger.info(&#39;Arguments passed. Getting data now ...&#39;)

        # get the target similarity data for plotting, pick the targets
        def get_data():
            sim, ctrl_sim = self._get_similarity(samples, metric, 
                                                 differential=differential,
                                                 drop_ctrl=differential)
            sim = sim.xs(display_markergenes, 1, 0)
            if rank_samples:
                if differential:
                    order = sim.max(1).sort_values(ascending=False).index
                else:
                    order = sim.min(1).sort_values().index
                sim = sim.reindex(order)
            
            # slice that selects the targets in the ranking
            drop = slice(int(n_targets/2), -int(n_targets/2)) if display_negative \
                   else slice(-1, n_targets-1, -1)
            
            asc = True if metric == &#39;euclid&#39; and not differential else False
            data = dict.fromkeys(sim.index, None)
            def sel_trgs(smp_row):                
                trgs = smp_row.iloc[0].sort_values(ascending=asc)
                data[trgs.name] = trgs.drop(trgs.index[drop])
            sim.groupby(level=0).apply(sel_trgs)
            return data, ctrl_sim
        
        # get plot global limits
        def get_caps():
            if xlim_range is not None:
                return xlim_range
            else:
                maxi = max([trg_vals.max() for trg_vals in list(data.values())])
                mini = min([trg_vals.min() for trg_vals in list(data.values())])
                ext = max([abs(maxi), abs(mini)]) *.15
                lims = [mini -ext, maxi +ext]
                if lims[0]&gt;=0 and lims[1]&gt;=0:
                    lims[lims.index(min(lims))] = 0
                elif lims[0]&lt;=0 and lims[1]&lt;=0:
                    lims[lims.index(max(lims))] = 0
                return lims

        # built 2 lists with widths and heights in inches of every axes
        def get_plot_sizes():
            fig_widths = [.0001] *5
            fig_widths[0] = targetlabels_space if targetlabels_space else \
                            config.BP_LEFT   
            if not hide_colorbar:
                fig_widths[1] = config.BP_Y_COLORBAR
            fig_widths[2] = config.BP_BARSPACE
            fig_widths[3] = .04
            fig_widths[4] = config.BP_RIGHT
            
            fig_heights = [.0001] *4
            fig_heights[0] = config.BP_TOP
            fig_heights[1] = config.BP_BARWIDTH_SIZE *n_targets
            fig_heights[2] = 0
            fig_heights[3] = config.BP_BOTTOM
            return fig_widths, fig_heights
        
        # draw plot
        def do_plot(i, dat):
            height, width = sum(fig_heights), sum(fig_widths)
            fig, axes = util._init_figure(fig_widths, fig_heights, (1, 2), 
                                          (.04,0))
            ax = axes[1]
            if spines:
                ax.spines[&#39;right&#39;].set_visible(True)
                ax.spines[&#39;top&#39;].set_visible(True)

            # set plot title
            if title and title not in (&#39;None&#39;, &#39;none&#39;, &#39;False&#39;, &#39;false&#39;, &#39;F&#39;, &#39;f&#39;):
                if title == True:
                    this_t = util._make_title(differential, metric, s_name, 
                                              self.name, pref=&#39;ranked &#39;)
                elif title and isinstance(title, (list, tuple)):
                    this_t = title[i]
                else:
                    this_t = title
                if not pivot:
                    fig.suptitle(this_t, y=1- (config.BP_TOP/height)*.6,
                                 fontsize=config.FONTS)
                else:
                    ax.get_yaxis().set_label_position(&#39;right&#39;)
                    ax.set_ylabel(this_t, rotation=-90, labelpad=25)

            # setup y axis including the colorbar
            ax.spines[&#39;left&#39;].set_visible(True)
            n = dat.shape[0] if not display_negative else dat.shape[0] +1
            ylim = n, -1
            yts = np.arange(n)
            [(ax.set_ylim(ylim), ax.set_yticks(yts)) for ax in axes]
            ylbls = dat.index.tolist()
            if not hide_colorbar:
                cols = self.get_colors(ylbls)
                if display_negative:
                    cols.insert(int(len(ylbls)/2), &#39;w&#39;)
                axes[0].bar(0, 1, color=cols, bottom=yts-.5)
            # if negative, insert a gab between the two groups 
            if display_negative:
                ylbls.insert(int(len(ylbls)/2), &#39;&#39;)
                dat = dat.append(pd.Series(0, [&#39;&#39;])).reindex(ylbls)
                # delta half-height/ width of split line between pos. &amp; neg. group
                d_hh = (.01/fig_heights[1]) /2
                d_wh = (.03/fig_widths[2])
                line_args = {&#39;xdata&#39;: (-d_wh, d_wh), &#39;transform&#39;: ax.transAxes, 
                             &#39;clip_on&#39;: False, &#39;color&#39;: &#39;k&#39;}
                ax.add_line(Line2D(ydata=(.5-d_hh*1.25, .5-d_hh*.25), **line_args))
                ax.add_line(Line2D(ydata=(.5+d_hh*.25, .5+d_hh*1.25), **line_args))
            if not hide_targetlabels:
                axes[0].tick_params(labelleft=True)
                fs = config.FONTS*targetlabels_size if targetlabels_size else \
                     config.FONTS
                if not pivot:
                    axes[0].set_yticklabels(ylbls, fontsize=fs)
                else:
                    axes[0].set_yticklabels(ylbls, rotation=-45, ha=&#39;right&#39;, 
                                            x=-.5, rotation_mode=&#39;anchor&#39;, 
                                            fontsize=fs)
            
            # setup x axis
            xlim = lims
            if not pivot:
                ax.spines[&#39;bottom&#39;].set_visible(True)
                ax.tick_params(bottom=True, labelbottom=True)
            else:
                ax.spines[&#39;top&#39;].set_visible(True)
                ax.tick_params(top=True, labeltop=True, labelrotation=-90)
                ax.xaxis.set_label_position(&#39;top&#39;)
            ax.set_xlim(xlim)
            ax.set_axisbelow(True)
            ax.xaxis.grid(alpha=0.8, linestyle=&#39;dashed&#39;)

            if metric == &#39;euclid&#39; and differential:
                xlbl = config.EUCLID_DIFF
            elif metric == &#39;euclid&#39; and not differential:
                xlbl = config.EUCLID_ABS
            elif metric == &#39;cosine&#39; and differential:
                xlbl = config.COSINE_DIFF
            elif metric == &#39;cosine&#39; and not differential:
                xlbl = config.COSINE_ABS
            elif metric == &#39;pearson&#39; and differential:
                xlbl = config.PEARSON_DIFF
            elif metric == &#39;pearson&#39; and not differential:
                xlbl = config.PEARSON_ABS
            elif metric == &#39;intersect&#39;:
                xlbl = config.INTERSECT

            # for absolute euclid sim., mark the untreated base if available
            if not differential and samples._ctrl and not hide_base_lines:
                xs = ctrl_sim.loc[samples._ctrl, display_markergenes]
                xs = xs.reindex(ylbls, axis=1)
                ax.vlines(xs, yts-.4, yts+.4, linewidth=.5)
                xlbl += &#39;\n(line = base)&#39;
            ax.set_xlabel(xlbl, labelpad=5)

            if not colored_bars:
                cols = config.colors[19]
            else:
                blue = config.colors[18] 
                red = config.colors[14]
                cols = [red if v &gt;0 else blue for v in dat.values]
                
            ax.barh(yts, dat, color=cols)
            return fig, axes

        spacer.info(&#39;\n\n&#39; + log_plot)
        logger.info(&#39;Plot: {} &amp; {}&#39;.format(self.name, samples.name))
        _check_args()
        data, ctrl_sim = get_data()
        lims = get_caps()

        fig_widths, fig_heights = get_plot_sizes()
        spacer.info(&#39;&#39;)
        logger.info(&#39;Drawing...&#39;)
        if filename:
            filename, pp = util._open_file(filename)
            ftype = filename[-4:]
        ret = {}
        for i, (s_name, dat) in enumerate(data.items()):
            fig, axes = do_plot(i, dat)
            spacer.info(&#39;{}/{} --- {}&#39;.format(i+1, len(data), s_name))
            if plt_show:
                plt.show()
            ret.update({s_name: (fig, axes, dat)})
            if filename:
                this_png_fn = &#39;{}_{}.{}&#39;.format(filename[:-4], s_name, ftype)
                util._save_file(fig, filename=this_png_fn, pp=pp)
        if filename:
            if pp:
                pp.close()
            logger.info(&#39;Plots saved at {}/{}\n\n&#39;
                        .format(os.path.abspath(os.curdir), filename))
        return ret </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="main.targets.targets"><code class="flex name class">
<span>class <span class="ident">targets</span></span>
<span>(</span><span>markergenes=None, expression=None, name=None, ignore_down_mgs=False, override_namematcher=False, species=None, log=True)</span>
</code></dt>
<dd>
<section class="desc"><p>The data to compare similarity against.</p>
<p>targets can hold lists of marker genes and expression data identifying a
collection of comparative transcriptional identities, the targets. </p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt>marker genes (optional): Directory with deseq2 output, directories</dt>
<dt>with up- and (optional) down gene lists or pandas.DataFrame.</dt>
<dt>Defaults to None. Gene list data has an ensg key in the first column</dt>
<dt>or contains an 'ensg' column label. 'Up-marker genes' should list</dt>
<dt>genes highly expressed in targets, 'down-marker genes' are those</dt>
<dt>expected to be low. When passing a DataFrame, the index should</dt>
<dt>consist of ensg keys, the columns of a pandas.MultiIndex with 'up'</dt>
<dt>or 'up' &amp; 'down' at level 0 and the element names at level 1.</dt>
<dt>The dtype is bool, marker genes are stored as 'True'. If None, all</dt>
<dt>expression values are considered as 'marker genes'.</dt>
<dt><strong><code>expression</code></strong> :&ensp;optional</dt>
<dd>TSV expression file or pandas.DataFrame.
Defaults to None.
The TSV input should have an ensg key in the first column or an ensg
column label. Columns <code>loc</code>, <code>name</code>, <code>tss_loc</code> and <code>strand</code> are
removed automatically. The data should be exclusively numerical
without NaN's. When passing a DataFrame, the data can be log2-
and z-transformed with an ensg key index and pandas.MultiIndex
columns with the element names at level 0, and <code>log2</code> &amp; <code>z</code> at
level 1. </dd>
<dt><strong><code>ignore_down_mgs</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Even if found in 'marker gene' input,
do not use the down marker genes for the analysis. Defaults to False.</dd>
<dt><strong><code>override_namematcher</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When both 'marker genes' and
'expression' passed, this overrides the element names in
'marker genes'. Defaults to False. When False, element names in
'marker genes' and 'expression' are expected to match perfectly.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name label of the targets. Defaults to 'Targets'.
Used in logging and plot annotations.</dd>
<dt><strong><code>species</code></strong> :&ensp;<code>str</code>, <code>optinoal</code></dt>
<dd>Species of the targets instance. Can be 'mouse'
or 'human'. Defaults to None. This is required when genes are
annotated for the gene_similarity_heatmap function.</dd>
<dt><strong><code>log</code></strong></dt>
<dd>(bool, optional): Log the targets initiation. Defaults to True.</dd>
</dl>
<h2 id="note">Note</h2>
<p>At least one of 'diff_genes' and 'expression' must be passed. When both
are passed, the inputs must have the same element order. Gene list
data is automatically alphabetically sorted, hence the expression order
should concur with this.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class targets(_differential):
    &#34;&#34;&#34;The data to compare similarity against.

    targets can hold lists of marker genes and expression data identifying a 
    collection of comparative transcriptional identities, the targets. 

    Arguments:
        marker genes (optional): Directory with deseq2 output, directories 
            with up- and (optional) down gene lists or pandas.DataFrame. 
            Defaults to None. Gene list data has an ensg key in the first column 
            or contains an &#39;ensg&#39; column label. &#39;Up-marker genes&#39; should list 
            genes highly expressed in targets, &#39;down-marker genes&#39; are those 
            expected to be low. When passing a DataFrame, the index should 
            consist of ensg keys, the columns of a pandas.MultiIndex with &#39;up&#39; 
            or &#39;up&#39; &amp; &#39;down&#39; at level 0 and the element names at level 1. 
            The dtype is bool, marker genes are stored as &#39;True&#39;. If None, all 
            expression values are considered as &#39;marker genes&#39;.
        expression (optional): TSV expression file or pandas.DataFrame. 
            Defaults to None.
            The TSV input should have an ensg key in the first column or an ensg 
            column label. Columns `loc`, `name`, `tss_loc` and `strand` are 
            removed automatically. The data should be exclusively numerical 
            without NaN&#39;s. When passing a DataFrame, the data can be log2- 
            and z-transformed with an ensg key index and pandas.MultiIndex 
            columns with the element names at level 0, and `log2` &amp; `z` at 
            level 1. 
        ignore_down_mgs (bool, optional): Even if found in &#39;marker gene&#39; input, 
            do not use the down marker genes for the analysis. Defaults to False.
        override_namematcher (bool, optional): When both &#39;marker genes&#39; and 
            &#39;expression&#39; passed, this overrides the element names in 
            &#39;marker genes&#39;. Defaults to False. When False, element names in 
            &#39;marker genes&#39; and &#39;expression&#39; are expected to match perfectly.
        name (str, optional): Name label of the targets. Defaults to &#39;Targets&#39;. 
            Used in logging and plot annotations.
        species (str, optinoal): Species of the targets instance. Can be &#39;mouse&#39;
            or &#39;human&#39;. Defaults to None. This is required when genes are 
            annotated for the gene_similarity_heatmap function.
        log: (bool, optional): Log the targets initiation. Defaults to True.
        
    Note:
        At least one of &#39;diff_genes&#39; and &#39;expression&#39; must be passed. When both 
        are passed, the inputs must have the same element order. Gene list
        data is automatically alphabetically sorted, hence the expression order
        should concur with this.
    &#34;&#34;&#34;
    def __init__(self, markergenes=None, expression=None, name=None, 
                 ignore_down_mgs=False, override_namematcher=False, 
                 species=None, log=True):
        # call _differential __init__ method
        super().__init__(diff_genes=markergenes, expression=expression, 
                         name=name, override_namematcher=override_namematcher, 
                         log=log)
        # define if down marker genes are used
        self._down_mgs = not ignore_down_mgs
        self._species = species 

        self._trg_sims = {}
        self._gene_sims = {}
        
        # remove down mgs from _diff if in there but not desired by the user
        if self._has_diff:
            if not self._down_mgs and &#39;down&#39; in self._diff.columns.unique(0):
                self._diff.drop(&#39;down&#39;, axis=1, level=0, inplace=True)
            elif &#39;down&#39; not in self._diff.columns.unique(0) and self._down_mgs:
                self._down_mgs = False
            if log:
                spacer.info(&#39;&#39;)
                n = self._diff.sum().unstack(0).reindex(self.names).to_string()
                logger.info(&#39;Number of marker genes: \n{}&#39;.format(n))
        # inform that not passing marker genes is not recommended
        elif log:
            self._down_mgs = False
            spacer.warning(&#39;&#39;)
            logger.warning(&#39;The targets `{}` are initiated without &#39;
                           &#39;`marker genes`. Note that comparing against all &#39;
                           &#39;genes can lead to low accuracy for defining &#39;
                           &#39;transcriptional similarity.&#39;.format(self.name))
        
        # _expr_mgs store
        # s a mask of _expr that holds only the marker genes
        if self._has_expr:
            expr_mgs = util._add_mg_types(self._expr.copy(), self._down_mgs)
            if self._has_diff: 
                mg_mask = lambda trg: trg.mask(~self._diff[trg.columns[0][:-1]])
                expr_mgs = expr_mgs.groupby(level=(0,1), axis=1).apply(mg_mask)
                self._expr_mgs = expr_mgs.reindex(self._mgs)
            else:
                self._expr_mgs = expr_mgs
        if log:
            spacer.info(&#39;\n\n&#39;)
        self._log_init(log)

    def __repr__(self):
        &#34;&#34;&#34;Get a readable summary of the samples instance&#34;&#34;&#34;
        return (&#39;\n=|=|= targets-instance =|=|=\nname = {};\nelements = {};\n&#39;
                &#39;n = {};\nmarker genes data = {};\nexpression data = {}\n&#39;
                .format(self.name, self.names, len(self), self._has_diff, 
                        self._has_expr))
    @property
    def _mgs(self):
        &#34;&#34;&#34;Get the genes that are at least the marker gene of one target&#34;&#34;&#34;
        if self._has_diff:
            return self._diff[self._diff.any(1)].index
        elif self._has_expr:
            return self._expr[self._expr.any(1)].index

    @property
    def _mg_types(self):
        &#34;&#34;&#34;Get the marker gene types present in the targets instance&#34;&#34;&#34;
        return [&#39;up&#39;, &#39;down&#39;] if self._down_mgs else [&#39;up&#39;]

    def _compute_similarity(self, samples, metric, log=True):
        &#34;&#34;&#34;Core function computing the similarity between samples and targets
            for metrics &#39;euclid&#39;, &#39;intersect&#39; &#39;cosine&#39; and &#39;pearson&#39;. A 
            similarity matrix with the respective samples is stored in trg_sims 
            and gene_sim.
        &#34;&#34;&#34;
        # check marker gene detection before computing similarity
        det = self.plot_detec_mgs_prop(samples, filename=None, log=log)
        det = det.reindex(self.names, level=1)
        keep = det[det.proportion &gt;config.DROP_TARGET_DETEC_THR].index.unique(1)
        if len(keep) != len(self):
            # drop targets with too few detected genes
            dr = pd.Index(self.names).difference(keep).tolist()
            if log:
                logger.info(&#39;{} target elements dropped due to marker gene &#39;
                            &#39;detection proportions lower {} &#39;&#39;(set in &#39;
                            &#39;config.DROP_TARGET_DETEC_THR):\n{}&#39;
                            .format(len(dr), config.DROP_TARGET_DETEC_THR, dr))
            self.slice_elements(keep, inplace=True, log=False)
            # self._compute_similarity(samples, metric log=log)
        if log:
            spacer.info(&#39;&#39;)
            logger.info(&#39;Computing similarity `{}` of samples `{}` and targets: &#39;
                        &#39;`{}` ... &#39;.format(metric, samples.name, self.name))
        # get expression data or gene list data of samples and targets
        if metric != &#39;intersect&#39;:
            # get the z-data of targets marker genes and all samples genes
            trg_data = self._expr_mgs.xs(&#39;z&#39;, 1, 2)
            smp_data = samples._expr.xs(&#39;z&#39;, 1, 1)
        else:
            # get gene list data (bool) and substitute diff data with +1 for 
            # up genes, -1 for down. Samples up and down lists are merged
            smp_data = util._bool_to_int_genes(samples._diff, return_merged=True)
            diff_mgs = self._diff.reindex(self._mgs)
            trg_data = util._bool_to_int_genes(diff_mgs, trans_updown=False)
            trg_data.mask(trg_data == 0, inplace=True)
        
        def compute_trg_sim(trg_d):
            det = trg_d.index[trg_d.notna()].intersection(smp_data.index)
            trg = trg_d.reindex(det)
            smp_d = smp_data.reindex(det)
            if metric == &#39;cosine&#39;:
                return smp_d.apply(lambda smp: (distance.cosine(smp, trg)-1)*-1)
            elif metric == &#39;pearson&#39;:
                return smp_d.apply(lambda smp: (distance.correlation(smp, trg)-1)*-1)
            else:
                # additionally save per gene similarity matrix here
                if metric == &#39;euclid&#39;:
                    gene_sims.append(smp_d.apply(lambda smp: abs(smp-trg)))
                    return gene_sims[-1].abs().mean()
                elif metric == &#39;intersect&#39;:
                    # this returns a matric representing matches and mismatches
                    gene_sims.append(smp_d.apply(lambda smp_d: abs(smp_d+trg) -1))
                    return gene_sims[-1].mean()
        if metric in [&#39;euclid&#39;, &#39;intersect&#39;]:
            gene_sims = []
            trg_sim = trg_data.apply(compute_trg_sim)
            
            # per gene data saving
            gene_sim = pd.concat(gene_sims, axis=1, sort=False)
            idx = [*[trg_data.columns.unique(i) for i in (0,1)], smp_data.columns]
            gene_sim.columns = pd.MultiIndex.from_product(idx)
            self._gene_sims[&#39;{}-{}&#39;.format(id(samples), metric)] = gene_sim
        else:
            trg_sim = trg_data.apply(compute_trg_sim)
        trg_sim = util._add_mgtmean(trg_sim)
        self._trg_sims[&#39;{}-{}&#39;.format(id(samples), metric)] = trg_sim

    def _get_similarity(self, samples, metric, which_sim=&#39;target_sim&#39;, 
                          differential=False, drop_ctrl=True, 
                          inters_to_updown_not=False, log=True):
        &#34;&#34;&#34;Specifically access target similarity (trg_sims) and gene similarity 
            (gene_sims) data. Returns 2 elements, either target similarity and 
            ctrl target similarity or per gene similarity and per gene control 
            similarity. Option for differential and absolute similarities.
        &#34;&#34;&#34;
        # check if similarity has already been computed, if not do similarity
        try:
            key = &#39;{}-{}&#39;.format(id(samples), metric)
            trg_sim = self._trg_sims[key].copy()
        except KeyError:
            self._compute_similarity(samples, metric, log=log)
            trg_sim = self._trg_sims[key].copy()
        if log:
            logger.info(&#39;Selecting and processing similarity data...&#39;)

        # ensure the similarity matrix has the correct ordering 
        t_ord = trg_sim.columns.unique(1)
        val_t_ord = pd.Index(self.names)
        val_t_ord = val_t_ord.drop(val_t_ord.difference(t_ord))
        if t_ord.tolist() != val_t_ord.tolist():
            trg_sim = trg_sim.reindex(val_t_ord, level=1, axis=1)
        s_ord = trg_sim.index
        val_s_ord = samples.names
        if s_ord.tolist() != val_s_ord:
            trg_sim = trg_sim.reindex(val_s_ord)

        # return target similarity
        if which_sim == &#39;target_sim&#39;:
            sim = trg_sim
            # expression based metrics
            if metric != &#39;intersect&#39;:
                if samples._ctrl:
                    ctrl_sim = sim.xs(samples._ctrl, drop_level=False)
                    if drop_ctrl:
                        sim.drop(samples._ctrl, inplace=True)
                    if differential:
                        sim = sim.apply(lambda smp: smp - ctrl_sim, axis=1)
                        # return not change but the reduction in Eucl. dist.
                        if metric == &#39;euclid&#39;:
                            sim *= -1
                    return sim, ctrl_sim.to_frame().T
                else:
                    return sim, None
            # gene list based metrics (intersect is differential by itself)
            else:
                if samples._ctrl and drop_ctrl:
                    sim.drop(samples._ctrl, inplace=True)
                # instead of a control, the number of marker genes are returned
                n_mgs = self._diff.sum()
                n_mgs = n_mgs.append(n_mgs.groupby(level=1, axis=0).mean())
                return sim, pd.DataFrame([n_mgs.values], [&#39;n_mgs&#39;], sim.columns)
        
        # return gene similarity, only available for euclid and intersect metric
        elif which_sim == &#39;gene_sim&#39;:
            sim = self._gene_sims[key].copy()
            if metric == &#39;euclid&#39;:
                if samples._ctrl:
                    ctrl_sim = sim.xs(samples._ctrl, 1, 2, drop_level=False)
                    if drop_ctrl:
                        sim.drop(samples._ctrl, axis=1, level=2, inplace=True)
                    if differential:
                        c_mask = np.repeat(ctrl_sim.values, axis=1, 
                                           repeats=len(sim.columns.unique(2)))
                        sim = c_mask - sim
                    return sim, ctrl_sim
                else:
                    return sim, None
            elif metric == &#39;intersect&#39;:
                if samples._ctrl and drop_ctrl:
                    sim.drop(samples._ctrl, axis=1, level=2, inplace=True)
                # by default sim holds matches (1) and mismatches (-1) 
                # this option makes -1 the positive value for down-marker genes
                if inters_to_updown_not and self._down_mgs:
                    sim[&#39;down&#39;] *= -1
                return sim, None
            
    def plot_detec_mgs_prop(self, samples, plt_show=False, 
                            filename=None, specific_target_labels=None, log=True):
        &#34;&#34;&#34;Show the proportion of detected marker genes in logs and a histogram.

            Useful for adjusting the DROP_TARGET_DETEC_THR value.

            Args:
                samples (samples): The samples instance to check the detection 
                    rate for.
                plt_show (bool, optional): Directly the histogram in a new
                    window. Defaults to False.
                filename (str, optional): Filename to save the generated 
                    histogram. Defaults to detec_mgs_prop. + config.SAVE_FORMAT.
                    None results in no file being saved.
                specific_target_labels (list, optional): define a specific set 
                    of target labels to display. Defaults to None
            Returns:
                det: A DataFrame with detection values used for logging and 
                    plotting
            Note:
                When the proportion of detection is at 0 for all targetss, an 
                error is raised.
        &#34;&#34;&#34;
        # get proportion of detected marker genes
        if self._has_diff:
            trg_d = self._diff
        elif self._has_expr:
            cols = pd.MultiIndex.from_product((self._mg_types, self.names))
            trg_d = pd.DataFrame(True, self._expr.index, cols)
        smp_from = samples._expr if samples._has_expr else samples._diff
        smp_d = smp_from.reindex(self._mgs).notna().iloc(1)[0]
        det = trg_d.reindex(self._mgs).apply(lambda trg: trg &amp; smp_d).sum()
        n_mgs = trg_d.sum()
        order = (det/n_mgs).sort_values().index

        # log proportion of detected marker genes
        det = pd.DataFrame({&#39;n marker genes&#39;: n_mgs.reindex(order), 
                            &#39;detected in samples&#39;: det.reindex(order).values, 
                            &#39;proportion&#39;: (det/n_mgs).reindex(order).values})
        n_trgs = 10 if not len(order) &lt;20 else int(len(order)/2)
        edges = order.droplevel(0)[:n_trgs].append(order.droplevel(0)[-n_trgs:])
        df_edges = det.loc[(slice(None), edges), :].to_string()
        if log:
            spacer.info(&#39;&#39;)
            logger.info(&#39;Detection of targets ({}) marker genes in samples data &#39;
                        &#39;({}): \n{}\nShown are the {} edge proportion values.&#39;
                        .format(self.name, samples.name, df_edges, len(edges)))
        if (det[&#39;detected in samples&#39;] == 0).all():
            trg_genes = &#39;, &#39;.join(self._detec_genes[:3])
            smp_genes = &#39;, &#39;.join(samples._expr.index[:3]) if samples._has_expr \
                        else &#39;, &#39;.join(samples._diff.index[:3])
            msg = (&#39;None of the targets marker genes were detected in the &#39;
                   &#39;samples. This is likely due to non-matching indeces from a &#39;
                   &#39;species-mismatch. Targets gene index: {} ... Samples gene &#39;
                   &#39;index: {}. Check the input files.&#39;
                   .format(trg_genes, smp_genes))
            logger.error(msg)
            sys.exit(1)
        # draw the plot if filename is passed, otherwise only log and return df
        if filename or plt_show:
            if filename:
                filename, pp = util._open_file(filename)
            fig, ax = plt.subplots()
            ax.bar(np.arange(len(order)), det.proportion, edgecolor=&#39;k&#39;,
                   width=1, color=self.get_colors(order.get_level_values(1)))
            ax.hlines(config.DROP_TARGET_DETEC_THR, 0, len(self))
            ax.yaxis.grid(alpha=0.8, linestyle=&#39;dashed&#39;)
            ax.set_xlabel(self.name+&#39; (targets)&#39;)
            if specific_target_labels:
                xlbl = [lbl if lbl in specific_target_labels else &#39;&#39; 
                        for lbl in order]
                ax.set_xticks(np.arange(len(xlbl)))
                ax.set_xticklabels(xlbl, rotation=45, ha=&#39;right&#39;, 
                                rotation_mode=&#39;anchor&#39;)
            ax.set_ylabel(&#39;Proportion of detected marker genes in samples&#39;)
            tit = (&#39;Proportion of detected {} marker genes in {}\nline = drop &#39;
                   &#39;threshold&#39;).format(self.name, samples.name)
            ax.set_title(tit, fontsize=6)
            if plt_show:
                plt.show()
            if filename:
                util._save_file(fig, filename, pp, close_pp=True)
                logger.info(&#39;Plot saved at {}\n&#39;
                            .format(os.path.abspath(filename)))
            else:
                plt.close()
        return det

    def target_similarity_heatmap(self, 
                                  # plot data
                                  samples, 
                                  metric = None, 
                                  differential = True,
                                  display_markergenes = &#39;mean&#39;,
                                  # data ordering
                                  cluster_targets = False,
                                  cluster_samples = False,
                                  reorder_to_distance_bar = False,
                                  # general settings
                                  pivot = False,
                                  heatmap_width = None,
                                  heatmap_height = None,
                                  heatmap_range = None,
                                  distance_bar_range = None,
                                  specific_target_labels = None,
                                  targetlabels_space = None,
                                  samplelabels_space = None,
                                  targetlabels_size = None,
                                  samplelabels_size = None,
                                  title = True, 
                                  # show/ hide elements 
                                  hide_colorbar_legend = False,
                                  hide_distance_bar = False,
                                  hide_targetlabels = False,
                                  hide_targets_dendrogram = False,
                                  hide_targets_colorbar = False,
                                  hide_samplelabels = False,
                                  show_samples_dendrogram = False,
                                  show_samples_colorbar = False,
                                  # others
                                  plt_show = False,
                                  filename = &#39;target_similarity_hm&#39;,
                                  **kwargs):
        &#34;&#34;&#34;Plot the similarity of the samples with the targets in a heatmap.
        
        This gives a compact insight on transcriptional similarity with the 
        targets. Four different metrics can be picked to assess similarity: 
        &#39;euclid&#39;, &#39;cosine&#39; and &#39;pearson&#39; for expression inputs or &#39;intersect&#39; 
        for comparison based on diff. genes/ marker genes. Differential and 
        absolute similarity values are available options for investigating the 
        change or state in similarity with the targets.

        Args:
            =================== Plot data options ===================
            samples (samples): the data to rate similarity for.
            metric (str, optional): the similarity metric to use. Valid 
                options are &#39;euclid&#39;, &#39;intersect&#39;, &#39;cosine&#39;, &#39;pearson&#39;. Defaults 
                to None.&#39;euclid&#39; shows the mean euclidean distance towards the 
                target marker genes expression levels and requires `expression` 
                input for samples and targets. &#39;intersect&#39; will show the overlap 
                between diff. sample genes and target marker genes requiring 
                gene list input. &#39;cosine&#39; will compute the cosine similarity, 
                &#39;pearson&#39; the Pearson correlation coefficient. More details in
                publication. When None, set to &#39;cosine&#39; when expression input 
                was passed, or &#39;intersect&#39; when gene list data was passed.
            differential (bool, optional): plot the differential (change in)
                similarity from the untreated-,/ base-sample, or. the control 
                to other samples. Defaults to True. Requires a control to be 
                passed for the expression-based metrics. Cannot be False for 
                &#39;intersect&#39;-metric.
            display_markergenes (str, optional): specify the group of 
                marker genes to display similarity for. Defaults to &#39;mean&#39;. 
                Valid options are &#39;mean&#39;, &#39;up&#39;, &#39;down&#39;. Relevent when targets 
                are initiated with down-marker genes.

            =================== data ordering options ===================
            cluster_targets (bool, optional): cluster targets using the 
                euclidean distance. Defaults to False.
            cluster_samples (bool, optional): cluster samples using the 
                euclidean distance. Defaults to False.
            reorder_to_distance_bar (bool, optional): reorder the targets
                from lowest to highest base distance. Defaults to False. 
                Cannot be True when  &#39;cluster_targets&#39; is True aswell.
                For details, check the &#39;hide_distance_bar&#39; argument. 

            =================== general visual options ===================
            pivot (bool, optional): pivot the heatmap by 90 degrees. Defaults to 
                False. Useful for fitting the heatmap on a canvas. 
            heatmap_width (float, optional): multiplier to stretch/ squeeze 
                the heatmap squares in x direction. Defaults to None. 
                Useful for very low or high number of targets. For pivot = True
                this paramter controls the height. 
            heatmap_height (float, optional): multiplier to stretch/ squeeze 
                the heatmap squares in y direction. Defaults to None. 
                Useful for very low or high number of samples. For pivot = True
                this paramter controls the width. 
            distance_bar_range (list, optional): Define the range of values
                that form the colormap for the distance bar. Defaults to
                None. The list is interpreted as, [lower_limit, upper_limit]. 
                When None, the edges are defined to cover all occuring values. 
                
            specific_target_labels (list, optional): define a specific set of
                target labels to display. Defaults to None
            targetlabels_space (float, optional): define the size in inches
                to reserve for target labels, here, the white space on the
                bottom. Defaults to None. When None, refer to the values set in 
                config.HM_BOTTOM.
            samplelabels_space (float, optional): define the size in inches
                to reserve for sample labels, here, the white space on the
                left. Defaults to None. When None, refer to the value set in 
                config.HM_LEFT.
            targetlabels_size (float, optional): multiplier for adjusting 
                target label size. Defaults to None. Useful for very high or low 
                number of targets.
            samplelabels_size (float, optional): multiplier for adjusting 
                sample label size. Defaults to None. Useful for very high or low 
                number of samples.
            title (bool, str, optional): the plot title to set. Defaults to 
                True. For True, infer the title based on plot data inputs and 
                targets/ samples name attribute. Text input will be set as 
                the general title, False hides the title.
            kwargs: modify the constants defined in config. This is used as an 
                advanced adjustment of plot element sizes and the minimum 
                required marker genes detection proportion. This heatmap may be
                adjusted by the following paramters: DROP_TARGET_DETEC_THR,
                HM_LEFT, HM_TOP, HM_RIGHT, HM_BOTTOM, HM_WSPACE, 
                HM_HSPACE, HM_Y_COLORBAR, HM_X_COLORBAR, HM_DISTANCE_BAR, 
                HM_Y_DENDROGRAM, HM_X_DENDROGRAM, HM_SQUARE_SIZE, CB_LEFT, 
                CB_LEFT_SEC, CB_TOP, CB_WIDTH, CB_HEIGHT.
            
            =================== hide/show plot elements ===================
            hide_colorbar_legend (bool, optional): Do not plot the colorbar 
                legend. Defaults to False. Applies for all colorbar_legends.
            hide_distance_bar (bool, optional): Do not plot the distance 
                bar on top of the heatmap. Defaults to False. When True, the 
                control will appear in the main heatmap. For the expression-
                based metrics, this bar visualizes the absolute similarity of 
                the control with the targets. For the &#39;intersect&#39; metric, the 
                number of target marker genes is shown. Defaults to False.
            hide_targetlabels (bool, optional): Do not plot the target 
                labels at the bottom. Defaults to False.
            hide_targets_dendrogram (bool, optional): Do not plot the 
                targets dendrogram from clustering. Defaults to False. 
                Requires &#39;cluster_targets&#39; to be True. 
            hide_targets_colorbar (bool, optional): Do not plot the targets
                colorbar on the bottom of the heatmap. Defaults to False. 
                When colors are not set for the targets using the 
                set_colors() function, colors are set to white.
            hide_samplelabels (bool, optional): Do not plot the sample 
                labels at the left. Defaults to False.
            show_samples_dendrogram (bool, optional): Plot the samples 
                dendrogram from clustering. Defaults to False. Requires 
                &#39;cluster_samples&#39; to be True.
            show_samples_colorbar (bool, optional): Plot the samples
                colorbar on the left of the heatmap. Defaults to False. 
                When colors are not set for the targets using the 
                set_colors() function, colors are set to white. 

            =================== others ===================
            filename (str, optional): the filename for saving the figure.
                Defaults to &#39;target_similarity_hm.png&#39;. Supported filename 
                endings are .png and .pdf. If filename does not end with 
                these, the filetype is retrieved from conifg.SAVE_FORMAT.
                If None, the plot is not saved.
            plt_show (bool, optional): directly show the created plot in a new
                window. Defaults to False.
        &#34;&#34;&#34;
        # check user input for errors and incompatibilities
        def _check_args():
            nonlocal metric
            nonlocal differential

            nonlocal cluster_targets
            nonlocal reorder_to_distance_bar
            nonlocal hide_distance_bar
            nonlocal display_markergenes
            nonlocal distance_bar_range

            # check general basic input requirements
            r = util._check_args(self, samples, metric, differential, 
                                hide_distance_bar, reorder_to_distance_bar,
                                distance_bar_range, cluster_targets, 
                                display_markergenes)
            metric, differential, hide_distance_bar, reorder_to_distance_bar, \
            distance_bar_range, cluster_targets, display_markergenes = r
                
            config._update_consts(kwargs)
            spacer.info(&#39;&#39;)
            logger.info(&#39;Arguments passed. Getting data now ...&#39;)

        # get the specific similarity data, plot the mean of up and down mgs
        def get_data():
            sim, ctrl_sim = self._get_similarity(samples, metric, 
                                                 differential=differential,
                                                 drop_ctrl= not hide_distance_bar)
            if ctrl_sim is None:
                ctrl_sim =  pd.DataFrame(0, [0], sim.columns)
            return [sim.xs(display_markergenes, 1, 0), 
                    ctrl_sim.xs(display_markergenes, 1, 0)]

        # get plot lims
        def get_caps():
            # get min and max value in data, set to caps
            if heatmap_range is not None:
                low_cap, up_cap = heatmap_range
            else:
                mini = abs(data[0].min().min())
                maxi = abs(data[0].max().max())
                up_cap = round(max((mini, maxi)), 1)
                low_cap = -up_cap
            # for the distance bar, set lims to 0,max for euclid, intersect and 
            # to -1,1 for cosine, pearson
            if distance_bar_range is not None:
                low_db_cap, up_db_cap = distance_bar_range
            else: 
                if metric in [&#39;euclid&#39;, &#39;intersect&#39;]:
                    up_db_cap = round(data[1].iloc[0].max(), 1)
                    low_db_cap = 0
                elif metric == &#39;cosine&#39;:
                    up_db_cap = 1
                    low_db_cap = -1
                elif metric == &#39;pearson&#39;:
                    up_db_cap = 1
                    low_db_cap = round(data[1].iloc[0].min(), 1)
            # for absolute, both distance bar and main bar sacles must be equal
            if not differential:
                if heatmap_range is not None:
                    up_db_cap = up_cap
                    low_db_cap = low_cap
                elif metric == &#39;euclid&#39;:
                    up_cap = up_db_cap = max((up_cap, up_db_cap))
                    low_cap = low_db_cap
                elif metric in [&#39;cosine&#39;, &#39;pearson&#39;]:
                    up_cap = up_db_cap
                    low_cap = low_db_cap

            return low_cap, up_cap, low_db_cap, up_db_cap
        
        # built 2 lists with widths and heights in inches of every axes
        def get_plot_sizes():
            nplts = [4,3]
            fig_widths = [.0001] *(nplts[1] +3)
            fig_widths[0] = samplelabels_space if samplelabels_space else \
                            config.HM_LEFT

            if show_samples_colorbar:
                fig_widths[1] = config.HM_Y_COLORBAR
            fig_widths[2] = config.HM_SQUARE_SIZE * data[0].shape[1]
            if heatmap_width:
                fig_widths[2] *= heatmap_width
            if cluster_samples and show_samples_dendrogram:
                fig_widths[3] = config.HM_Y_DENDROGRAM
            fig_widths[4] = config.HM_WSPACE * (nplts[1]-1)
            fig_widths[5] = config.HM_RIGHT

            fig_heights = [.0001] *(nplts[0] +3)
            fig_heights[0] = config.HM_TOP
            if cluster_targets and not hide_targets_dendrogram:
                fig_heights[1] = config.HM_X_DENDROGRAM
            if not hide_distance_bar:
                fig_heights[2] = config.HM_DISTANCE_BAR
            fig_heights[3] = config.HM_SQUARE_SIZE * len(samples._names_noctrl)
            if heatmap_height:
                fig_heights[3] *= heatmap_height
            if not hide_targets_colorbar:
                fig_heights[4] = config.HM_X_COLORBAR
            fig_heights[5] = config.HM_HSPACE * (nplts[0]-1)
            fig_heights[6] = targetlabels_space if targetlabels_space else \
                             config.HM_BOTTOM

            return nplts, fig_widths, fig_heights

        # draw plot
        def do_plot():
            width, height = sum(fig_widths), sum(fig_heights)
            fig, axes = util._init_figure(fig_widths, fig_heights, nplts, 
                                       (config.HM_WSPACE, config.HM_HSPACE))
            sim, ctrl_sim = data

            # set plot title
            if title and title not in (&#39;None&#39;, &#39;none&#39;, &#39;False&#39;, &#39;false&#39;, &#39;F&#39;, &#39;f&#39;):
                if title and type(title) is not str:
                    this_t = util._make_title(differential, metric, 
                                              samples.name, self.name)
                else:
                    this_t = title
                if not pivot:
                    fig.suptitle(this_t, y=1- (config.HM_TOP/height)*.7, 
                                 fontsize=config.FONTS)
                else:
                    axes[2, 0].set_ylabel(this_t, labelpad=10)

            # cluster targets/ samples and draw dendrograms
            if cluster_targets:
                at = axes[0, 1] if not hide_targets_dendrogram else axes[0, 0]
                order = util._heatmap_cluster(sim, &#39;top&#39;, at, &#39;columns&#39;)
                sim, ctrl_sim = util._align_indices([sim, ctrl_sim], order)
            if cluster_samples:
                at = axes[2, 2] if show_samples_dendrogram else axes[0, 0]
                order = util._heatmap_cluster(sim, &#39;right&#39;, at, &#39;rows&#39;)
                sim = sim.reindex(order)
            axes[0, 0].set_visible(False)
            
            # draw distance effect bar
            if not hide_distance_bar:
                # set order to order of sorted values in distance bar (ctrl)
                if reorder_to_distance_bar:
                    order = ctrl_sim.iloc[0].sort_values().index
                    sim, ctrl_sim = util._align_indices([sim, ctrl_sim], order)
                # only draw colorbar legend if not absolute
                draw_cb = False if hide_colorbar_legend or not differential else True
                # label of the distance bar on the left
                if metric != &#39;intersect&#39; and not hide_samplelabels:
                    ctrl_lbl = samples._ctrl
                else:
                    ctrl_lbl = &#39;&#39;
                # general metric depended labling
                bar_args = {&#39;cmap&#39;: &#39;afmhot_r&#39;, &#39;vmin&#39;: low_db_cap, &#39;vmax&#39;: up_db_cap}
                if metric == &#39;euclid&#39;:                    
                    cb_lbl = &#39;Base &#39; + config.EUCLID_ABS
                    bar_args.update({&#39;cmap&#39;: &#39;afmhot&#39;})
                elif metric == &#39;cosine&#39;:
                    cb_lbl = &#39;Base &#39; + config.COSINE_ABS
                elif metric == &#39;pearson&#39;:
                    cb_lbl = &#39;Base &#39; + config.PEARSON_ABS
                elif metric == &#39;intersect&#39;:
                    cb_lbl = config.INTERSECT_DIST_BAR
                    bar_args.update({&#39;cmap&#39;: &#39;afmhot&#39;})
                util._plot_distance_bar(axes[1, :2], ctrl_sim,
                                            ctrl_lbl, bar_args, draw_cb, 
                                            cb_lbl, fig, pivot, width, height)

            # setup heatmap x,y axis, including the colorbars
            cols = self.get_colors(sim.columns) if not hide_targets_colorbar \
                   else None
            xlbl = sim.columns
            if specific_target_labels:
                xlbl = [lbl if lbl in specific_target_labels else &#39;&#39; for lbl in xlbl]
            util._setup_heatmap_xy(&#39;x&#39;, axes[3, 1], xlbl, pivot,
                                  hide_targetlabels, targetlabels_size, cols)
                   
            cols = samples.get_colors(sim.index[::-1]) if show_samples_colorbar \
                   else None
            util._setup_heatmap_xy(&#39;y&#39;, axes[2, 0], sim.index[::-1], pivot, 
                                   hide_samplelabels, samplelabels_size, cols)

            ax = axes[2, 1]
            ax.set_yticks(np.arange(0, sim.shape[0]))
            ax.set_xticks(np.arange(0, sim.shape[1]))
            hm_args = {&#39;vmin&#39;: low_cap, &#39;vmax&#39;: up_cap}
            hm_args[&#39;cmap&#39;] = &#39;RdBu_r&#39; if differential else &#39;afmhot_r&#39;
            if metric == &#39;euclid&#39; and differential:
                cb_lbl = config.EUCLID_DIFF
            elif metric == &#39;euclid&#39; and not differential:
                cb_lbl = config.EUCLID_ABS
                hm_args[&#39;cmap&#39;] = &#39;afmhot&#39;
            elif metric == &#39;cosine&#39; and differential:
                cb_lbl = config.COSINE_DIFF
            elif metric == &#39;cosine&#39; and not differential:
                cb_lbl = config.COSINE_ABS
            elif metric == &#39;pearson&#39; and differential:
                cb_lbl = config.PEARSON_DIFF
            elif metric == &#39;pearson&#39; and not differential:
                cb_lbl = config.PEARSON_ABS
            elif metric == &#39;intersect&#39;:
                cb_lbl = config.INTERSECT
            im = ax.imshow(sim.values, aspect=&#39;auto&#39;, **hm_args)
            
            # setup heatmap colorbar legend and draw
            if not hide_colorbar_legend:
                at = (config.CB_LEFT/width, 1- config.CB_TOP/height, 
                      config.CB_WIDTH/width, config.CB_HEIGHT/height)
                cax = fig.add_axes(at)
                cb = ax.figure.colorbar(im, cax=cax, orientation=&#39;horizontal&#39;) 
                
                bar_ticks = [hm_args[&#39;vmin&#39;], hm_args[&#39;vmax&#39;]]
                cb.set_ticks(bar_ticks)
                cb.ax.set_xticklabels(bar_ticks)
                if pivot:
                    cb.ax.tick_params(labelrotation=90)
                cb.ax.set_xlabel(cb_lbl)
                cb.ax.get_xaxis().set_label_position(&#39;top&#39;)

            return fig, axes, (sim, ctrl_sim)

        spacer.info(&#39;\n\n&#39; + log_plot)
        logger.info(&#39;Plot: {} &amp; {}&#39;.format(self.name, samples.name))
        _check_args()
        data = get_data()
        low_cap, up_cap, low_db_cap, up_db_cap = get_caps()

        nplts, fig_widths, fig_heights = get_plot_sizes()
        spacer.info(&#39;&#39;)
        logger.info(&#39;Drawing...&#39;)
        if filename:
            filename, pp = util._open_file(filename)
        fig, axes, data = do_plot()
        if plt_show:
            plt.show()
        if filename:
            util._save_file(fig, filename=filename, pp=pp, close_pp=True)
            logger.info(&#39;Plot saved at {}/{}\n\n&#39;
                        .format(os.path.abspath(os.curdir), filename))
        else:
            plt.close(fig)
        return fig, axes, data
        

    def gene_similarity_heatmap(self,
                                # plot data
                                samples,  
                                metric = None,
                                differential = True,
                                display_genes = &#39;variant&#39;,
                                gene_number = 45,
                                specific_genes = None,
                                custom_target_genelist = None,
                                # data ordering
                                cluster_genes = False,
                                cluster_samples = False,
                                reorder_to_distance_bar = False,
                                # general settings
                                pivot = False,
                                heatmap_width = None,
                                heatmap_height = None,
                                heatmap_range = None,
                                distance_bar_range = None,
                                sum_plot_range = None,
                                genelabels_space = None,
                                genelabels_size = None,
                                samplelabels_size = None,
                                samplelabels_space = None,
                                title = True, 
                                # show/ hide elements 
                                hide_colorbar_legend = False,
                                hide_distance_bar = False,
                                hide_sum_plot = False,
                                hide_genelabels = False,
                                hide_genes_dendrogram = False,
                                show_genes_colorbar = None,
                                hide_samplelabels = False,
                                show_samples_dendrogram = False,
                                show_samples_colorbar = False,
                                # others
                                filename = &#39;gene_similarity_hm&#39;,
                                plt_show = False,
                                **kwargs):
        &#34;&#34;&#34;Plot the single-gene similarities of the samples with the targets 
        in an array of heatmaps.
    
        This function reveals the drivers behind target similarity shifts. 
        Besides various gene extraction options, a genelist can be passed to 
        investigate specific similarity changes. On the right of the 
        heatmap, a bar plot visualizes a summery of the gene values.
        Two different metrics can be picked to assess similarity: 
        &#39;euclid&#39; for expression inputs or &#39;intersect&#39; for comparison based 
        on diff. genes/ marker genes. Differential and absolute gene
        similarity values are available options for investagting the change 
        in similarity. When targets were initiated with down-marker genes,
        a seperate heatmap for each marker gene type is drawn.

        Args:
            =================== Plot data options ===================
            samples (samples): the data to rate similarity for.
            metric (str, optional): the similarity metric to use. Valid 
                options are &#39;euclid&#39;, &#39;intersect&#39;, &#39;cosine&#39;, &#39;pearson&#39;. Defaults 
                to None.&#39;euclid&#39; shows the mean euclidean distance towards the 
                target marker genes expression levels and requires `expression` 
                input for samples and targets. &#39;intersect&#39; will show the overlap 
                between diff. sample genes and target marker genes requiring 
                gene list input. &#39;cosine&#39; will compute the cosine similarity, 
                &#39;pearson&#39; the Pearson correlation coefficient. More details in
                publication. When None, set to &#39;cosine&#39; when expression input 
                was passed, or &#39;intersect&#39; when gene list data was passed.
            differential (bool, optional): plot the differential (change in)
                similarity from the untreated-,/ base-sample, or. the control 
                to other samples. Defaults to True. Requires a control to be 
                passed for the expression-based metrics. Cannot be False for 
                &#39;intersect&#39;-metric.
            display_genes (str, optional): Extract a specific set of 
                marker genes to display for each target. Defaults to &#39;variant&#39;. 
                Valid options are &#39;variant&#39;, &#39;increasing&#39;, &#39;decreasing&#39; when 
                differential True, and &#39;variant&#39;, &#39;distant&#39;, &#39;similar&#39; for 
                differential False. To identify sample specific effects, these 
                metrics will sort according to outlaying sample values rather 
                then overall high/ low/ increasing etc. values. This is one of 
                the 3 gene selection options to choose from.
            gene_number (int, optional): The number of genes to plot for the 
                &#39;display_genes&#39; option. Defaults to 45. This option is 
                ignored for the two other gene selection options 
                &#39;specific_genes&#39; and &#39;custom_target_genelist&#39;. 
            specific_genes (list, optional): Specify the marker genes to 
                display in a list of gene names. Defaults to None. A gene 
                from this list is only displayed if it is a marker gene of 
                the specifc target and detected in the samples. This option can 
                be used idependently or in combination with &#39;display_genes&#39; for 
                adding specific genes of interest to the extracted ones. Genes 
                are annotated referencing enseble v.96.
            custom_target_genelist (list, optional): Specify a custom list 
                of gene names to display similarity for. Defaults to None. 
                Currently this option is only implemented for the &#39;euclid&#39; 
                similarity metric. The passed genelist will be used for all 
                targets. In contrast to &#39;specific_genes&#39;, the genes only need to 
                be detected in the targets instead of qualifying as specific 
                target marker genes. Still, genes need to be detected in the 
                samples. Genes are annotated referencing enseble v.96.
            
            =================== data ordering options ===================
            cluster_genes (bool, optional): cluster genes using the 
                euclidean distance. Defaults to False.
            cluster_samples (bool, optional): cluster samples using the 
                euclidean distance. Defaults to False.
            reorder_to_distance_bar (bool, optional): reorder the genes
                from lowest to highest base distance. Defaults to False. 
                Cannot be True when  &#39;cluster_genes&#39; is True aswell.
                For details, check the &#39;hide_distance_bar&#39; argument. 

            =================== general visual options ===================
            pivot (bool, optional): pivot the heatmap by 90 degrees. Defaults 
                to False. Useful for fitting the heatmap on a canvas. 
            heatmap_width (float, optional): multiplier to stretch/ squeeze 
                the heatmap squares in x direction. Defaults to None. For 
                pivot = True this paramter controls the height. 
                Useful for very low or high number of genes. 
            heatmap_height (float, optional): multiplier to stretch/ squeeze 
                the heatmap squares in y direction. Defaults to None. For 
                pivot = True this paramter controls the width.
                Useful for very low or high number of samples.
            distance_bar_range (list, optional): Define the range of values
                that form the colormap for the distance bar. Defaults to
                None. The list is interpreted as, [lower_limit, upper_limit]. 
                When None, the edges are defined to cover 90% of occuring values 
                ignoring outlayers. 
            sum_plot_range (list, optional): Define the lower- and upper 
                x-limits for the summary plot. Defaults to None. The list is 
                interpreted as, [lower_limit, upper_limit]. When None, the 
                x-limits are defined by adding 15% to the minimum and maximum
                values. 
            genelabels_space (float, optional): define the size in inches
                to reserve for gene labels, here, the white space on the
                bottom. Defaults to None. When None, refer to the values set in 
                config.HM_BOTTOM.
            samplelabels_space (float, optional): define the size in inches
                to reserve for sample labels, here, the white space on the
                left. Defaults to None. When None, refer to the value set in 
                config.HM_LEFT.
            genelabels_size (float, optional): multiplier for adjusting gene 
                label size. Defaults to None. Useful for very high or low 
                number of genes.
            samplelabels_size (float, optional): multiplier for adjusting 
                sample label size. Defaults to None. Useful for very high or low 
                number of samples.
            title (bool, str, optional): the plot title to set. Defaults to 
                True. For True, infer the title based on plot data inputs and 
                targets/ samples name attribute. Text input will be set as 
                the general title, False hides the title. A list of str will be
                set according to the list of plots.
            kwargs: modify the constants defined in config. This is used as an 
                advanced adjustment of plot element sizes and the minimum 
                required marker genes detection proportion. The heatmaps may be
                adjusted by the following paramters: DROP_TARGET_DETEC_THR,
                HM_LEFT, HM_TOP, HM_RIGHT, HM_BOTTOM, HM_WSPACE, 
                HM_HSPACE, HM_Y_COLORBAR, HM_X_COLORBAR, HM_DISTANCE_BAR, 
                HM_Y_DENDROGRAM, HM_X_DENDROGRAM, HM_SQUARE_SIZE, 
                G_HM_SUMPLOT_SIZEG_HM_UPDOWN_SPACE_SIZE, CB_LEFT, 
                CB_LEFT_SEC, CB_TOP, CB_WIDTH, 
                CB_HEIGHT.
            
            =================== hide/show plot elements ===================
            hide_colorbar_legend (bool, optional): Do not plot the colorbar 
                legend. Defaults to False. Applies for all colorbar_legends.
            hide_distance_bar (bool, optional): Do not plot the distance 
                bar on top of the heatmap. Defaults to False. When True, the 
                control will appear in the main heatmap. For the expression-
                based metrics, this bar visualizes the absolute similarity of 
                the control with the targets. For the &#39;intersect&#39; metric, the 
                number of target marker genes is shown. Defaults to False.
            hide_sum_plot (bool, optional): Do not generate the summary plot on
                the right visualizing the samples genes. Defualts to False.
                This plot shows the summarized similarity of all genes. It 
                computes like the target similarty, but limited to the displayed
                genes.
            hide_genelabels (bool, optional): Do not plot the gene 
                labels at the bottom. Defaults to False.
            hide_genes_dendrogram (bool, optional): Do not plot the 
                genes dendrogram from clustering. Defaults to False. 
                Requires &#39;cluster_genes&#39; to be True. 
            show_genes_colorbar (dict, bool, optional): Plot a genes colorbar on 
                the bottom of the heatmap. Defaults to None. A dictionary 
                should map gene names to colors. Mappings for genes not 
                displayed in the plot are ignored. The color for M=missing gene 
                keys is set to white. When, True and `specifc_genes` passed,
                the passed genes will be set to config.colors[1] (green). 
            hide_samplelabels (bool, optional): Do not plot the sample 
                labels at the left. Defaults to False.
            show_samples_dendrogram (bool, optional): Plot the samples 
                dendrogram from clustering. Defaults to False. Requires 
                &#39;cluster_samples&#39; to be True.
            show_samples_colorbar (bool, optional): Plot the samples
                colorbar on the left of the heatmap. Defaults to False. 
                When colors are not set for the targets using the 
                set_colors() function, colors are set to white. 

            =================== others ===================
            filename (str, optional): the filename for saving the figure.
                Defaults to &#39;gene_similarity_hm.pdf&#39;. Supported filename 
                endings are .png and .pdf. If filename does not end with 
                these, the filetype is retrieved from conifg.SAVE_FORMAT.
                If None, the plot is not saved.
            plt_show (bool, optional): directly show each created plot in a new
                window. Defaults to False.
        &#34;&#34;&#34;
        # check user input for errors and incompatibilities
        def _check_args():
            nonlocal metric
            nonlocal differential
            nonlocal display_genes
            nonlocal specific_genes
            nonlocal custom_target_genelist

            nonlocal hide_distance_bar
            nonlocal reorder_to_distance_bar
            nonlocal cluster_genes
            nonlocal show_genes_colorbar
            nonlocal distance_bar_range

            # check general basic input requirements
            r = util._check_args(self, samples, metric, differential, 
                                 hide_distance_bar, reorder_to_distance_bar, 
                                 distance_bar_range, cluster_genes)
            if r[0] == &#39;cosine&#39;:
                # default for per gene cannot be cosine, change to euclid here
                metric = &#39;euclid&#39;
            _, differential, hide_distance_bar, reorder_to_distance_bar, \
            distance_bar_range, cluster_genes, _ = r

            # check main data input
            if self._species not in [&#39;human&#39;, &#39;mouse&#39;]:
                logger.info(&#39;&#39;)
                logger.error(&#39;Invalid input for species: `{}`. Valid are `mouse` &#39;
                             &#39;and `human`. Initate targets with these species &#39; 
                             &#39;to use this function.&#39;.format(self._species))
                sys.exit(1)
            if metric == &#39;intersect&#39; and not hide_distance_bar:
                hide_distance_bar = True
                logger.warning(&#39;For the intersect metric, there is no distance&#39;
                               &#39;bar. `hide_distance_bar` was set to True.&#39;)
            if custom_target_genelist is not None and metric == &#39;intersect&#39;:
                logger.error(&#39;The `custom_target_genelist` option is &#39;
                             &#39;currentily not implemented for the similarity &#39;
                             &#39;metric `intersect`. Please choose an alternative &#39;
                             &#39;gene selection option.&#39;)
                sys.exit(1)
            if custom_target_genelist is not None and display_genes:
                display_genes = None
                logger.info(&#39;Both `display_genes` and &#39;
                            &#39;`custom_target_genelist` were passed. &#39;
                            &#39;`display_genes` will be ignored.&#39;)
            if display_genes:
                val = [&#39;variant&#39;, &#39;increasing&#39;, &#39;decreasing&#39;]
                if not differential:
                     val = [&#39;variant&#39;, &#39;distant&#39;, &#39;similar&#39;]
                if display_genes not in val:
                    logger.error(&#39;The passed value for display_genes: `{}` is &#39;
                                 &#39;invalid. Valid options when `differential` is&#39;
                                 &#39; {} are {}.&#39;
                                 .format(display_genes, differential, val))
                    sys.exit(1)
            elif custom_target_genelist is None and specific_genes is None:
                logger.error(&#39;None of `display_genes`, `specific_genes` or &#39;
                             &#39;`custom_target_genelist` were passed&#39;)
                sys.exit(1)
            elif custom_target_genelist is not None and specific_genes is not None:
                specific_genes = None
                msg = (&#39;Both `specific_genes` and `custom_target_genelist` were&#39;
                       &#39; passed. `specific_genes` will be ignored.&#39;)
                logger.info(msg)
            config._update_consts(kwargs)
            
            # modify arguments for convneience 
            if show_genes_colorbar == True:
                if specific_genes:
                    show_genes_colorbar = dict.fromkeys(specific_genes, 
                                                        config.colors[1])
                else:
                    show_genes_colorbar = None

            # get a list of generally valid annotated genes
            genes = pd.DataFrame({&#39;name&#39;: util.annotate(self._mgs, self._species), 
                                  &#39;ensg&#39;: self._mgs })
            if specific_genes is not None or custom_target_genelist is not None:
                # for gene input check if genes are detected in the target data
                if specific_genes is not None:
                    inp_gl = pd.Index(specific_genes).drop_duplicates()
                    val_gl = pd.Index(genes.name.values)
                    isin = &#39;marker genes&#39;
                elif custom_target_genelist is not None:
                    inp_gl = pd.Index(custom_target_genelist).drop_duplicates()
                    val_gl_ensg = self._detec_genes.intersection(samples._detec_genes)
                    isin = &#39;detected genes&#39;
                    val_gl = pd.Index(util.annotate(val_gl_ensg, self._species))
                
                inv = [g for g in inp_gl if g not in val_gl]
                inp_gl = inp_gl.drop(inv) 
                if inv:
                    logger.warning(&#39;{} ({}/{}) are not {} in any of the targets&#39;
                                   &#39; or are not detected in the samples. These &#39;
                                   &#39;genes will not be included.&#39;.format(inv,
                                    len(inv), len(inv)+len(inp_gl), isin))
                    if len(inv) == (len(inv)+len(inp_gl)):
                        sys.exit(1)
                # update passed list
                if specific_genes is not None:
                    specific_genes = inp_gl
                elif custom_target_genelist is not None:
                    genes = util.get_ensgs(inp_gl, self._species)
                    # duplicated indicies are painful in pandas...
                    if genes.name.duplicated().any():
                        val_gl = pd.Index(genes.ensg).intersection(val_gl_ensg)
                        genes = genes.reindex(genes.index[genes.ensg.isin(val_gl)])
                        if genes.name.tolist() != inp_gl.tolist():
                            try:
                                genes = genes.set_index(&#39;name&#39;).reindex(inp_gl)
                                genes.reset_index(inplace=True)
                                genes = genes.rename({&#39;index&#39;: &#39;name&#39;}, axis=1)
                            except Exception:
                                logger.warning(&#39;Input gene order could not be&#39;
                                               &#39;kept because of duplicate &#39;
                                               &#39;gene name issues.&#39;)
            logger.info(&#39;Arguments passed. Getting data now ...&#39;)
            return genes                   

        # get the specific similarity data and pick out the genes to display
        def get_data():
            # init a new target where all genes are marker genes of all targets
            if custom_target_genelist:
                nonlocal self
                expr = self._expr.reindex(genes.ensg).copy()
                args = {&#39;expression&#39;: expr}
                self = targets(name=&#39;custom genelist&#39;, ignore_down_mgs=True, 
                               log=False, **args)
            sim, ctrl_sim = self._get_similarity(samples, metric, &#39;gene_sim&#39;,
                                                 differential=differential,
                                                 drop_ctrl= not hide_distance_bar)

            # init mutable nested dict with target and markegene type keys
            data = dict((trg, dict((mgt, None) for mgt in self._mg_types))
                        for trg in self.names)
            # select genes, form the 3 data elements per-gene similarity (heatmap), 
            # ctrl_sim (distance_bar), target similarity (sumplot)
            def sel_genes(gene_sim, genes):
                mgt = gene_sim.columns[0][0]
                trg = gene_sim.columns[0][1]
                get_genes = pd.Index([])
                gene_sim.dropna(inplace=True)
                
                if display_genes:
                    # sort similarities based on passed metric, slice to gene number
                    if display_genes == &#39;variant&#39;:
                        idx = gene_sim.var(1).sort_values(ascending=False).index
                    elif metric == &#39;euclid&#39;:
                        if display_genes in [&#39;increasing&#39;, &#39;distant&#39;]:
                            idx = gene_sim.max(1).sort_values(ascending=False).index
                        elif display_genes in [&#39;decreasing&#39;, &#39;similar&#39;]:
                            idx = gene_sim.min(1).sort_values().index       
                    elif metric == &#39;intersect&#39;:
                        if display_genes.startswith(&#39;in&#39;) and mgt == &#39;down&#39; or \
                        display_genes.startswith(&#39;de&#39;) and mgt == &#39;up&#39;:
                            asc = True
                        elif display_genes.startswith(&#39;in&#39;) and mgt == &#39;up&#39; or \
                        display_genes.startswith(&#39;de&#39;) and mgt == &#39;down&#39;:
                            asc = False
                        idx = gene_sim.sum(1).sort_values(ascending=asc).index
                    get_genes = idx[:gene_number]
                    
                if specific_genes is not None:
                    # check if passed genelist in target marker genes add them 
                    # if not already in 
                    inp_ensg = util.get_ensgs(specific_genes, self._species).ensg
                    not_mg = filter(lambda ie: ie not in gene_sim.index, inp_ensg)
                    inv = genes.set_index(&#39;ensg&#39;).reindex(not_mg).name
                    if not inv.empty:
                        logger.info(&#39;{} not included: not marker genes of `&#39;
                                    &#39;{}-{}`&#39;.format(inv.tolist(), mgt, trg))
                    add = lambda ie: not (ie in get_genes or ie in inv)
                    add_genes = pd.Index(filter(add, inp_ensg))
                    if not add_genes.empty:
                        get_genes = get_genes.append(add_genes)
                elif custom_target_genelist:
                    get_genes = genes.ensg
                
                if get_genes.empty:
                    logger.error(&#39;No genes were picked for {}-{}. Check input.&#39;
                                 .format(mgt, trg))
                    sys.exit(1)
                # index per gene similarity to final gene list
                # per gene similarity for heatmap
                gs = gene_sim.reindex(get_genes)
                # target similarity for heatmap
                ts = gs.mean()

                # control similarity for distance bar
                if metric == &#39;euclid&#39; and not hide_distance_bar:
                    cs = ctrl_sim.loc[get_genes, (mgt, trg, samples._ctrl)].to_frame().T
                else:
                    cs = None
                data[trg][mgt] = (gs.T, cs, ts)
            
            # iterate target+marker gene type
            sim.groupby(axis=1, level=(0,1), sort=False).apply(sel_genes, genes)
            return data

        # get data limits across all targets and marker gene types to plot with 
        # one consistent heatmap range 
        def get_caps():
             # unpack nested dict into the 3 plot data elements       
            data_l = [e for dat in list(data.values())
                      for d in list(dat.values()) for e in d]
            # gene sim (heatmap), ctrl sim (distance bar) target sim (sum plot)
            gs, cs, ts = [data_l[get::3] for get in (0,1,2)]
            
             # get number of genes per plot
            n_genes = [ts.shape[1] for ts in gs]
            if self._down_mgs:
                n_genes = [max(gs[i].shape[1], gs[i+1].shape[1]) 
                           for i in range(0, len(gs), 2)]

             # get sum plot limits
            if sum_plot_range is not None:
                ts_lim = sum_plot_range
            else:
                ts_min = min([sim.min() for sim in ts])
                ts_max = max([sim.max() for sim in ts])
                ts_lim = [ts_min -abs(ts_min*.15), ts_max +abs(ts_max*.15)]
                # make sure 0 is included
                if differential or True:
                    if ts_lim[0]&gt;=0 and ts_lim[1]&gt;=0:
                        ts_lim[ts_lim.index(min(ts_lim))] = 0
                    elif ts_lim[0]&lt;=0 and ts_lim[1]&lt;=0:
                        ts_lim[ts_lim.index(max(ts_lim))] = 0
            
            # get per gene heatmap range (only required for euclid)
            if metric == &#39;euclid&#39;:
                if heatmap_range is not None:
                    low_cap, up_cap = heatmap_range
                else:
                    mini = [sim.min().sort_values()[int(sim.shape[1]*.05)] for sim in gs]
                    maxi = [sim.max().sort_values()[int(sim.shape[1]*.95)] for sim in gs]
                    up_cap = round(max((abs(min(mini)), abs(max(maxi)))), 1)
                    low_cap = -up_cap if differential else 0
                
                # get distance bar range
                if not hide_distance_bar:
                    if distance_bar_range is not None:
                        low_db_cap, up_db_cap = distance_bar_range
                    else: 
                        up_db_cap = round(max([sim.iloc[0].sort_values()[int(sim.shape[1]*.95)]
                                            for sim in cs]), 1)
                        low_db_cap = 0

                    # make sure heatmap and distance bar ranges align
                    if not differential:
                        if heatmap_range is not None:
                            up_db_cap = up_cap
                            low_db_cap = low_cap
                        else:
                            up_cap = up_db_cap = max((up_cap, up_db_cap))
                            low_cap = low_db_cap
                else:
                    up_db_cap = low_db_cap = None
                return up_cap, low_cap, up_db_cap, low_db_cap, ts_lim, n_genes
            # for the intersect mertic, the values can only be -1, 0 and 1
            elif metric == &#39;intersect&#39;:
                return 1, -1, None, None, ts_lim, n_genes
        
        # built 2 lists with widths and heights in inches of every axes
        def get_plot_sizes():
            nplts = [4, 4]
            # default size of an exes is 0
            fig_widths = [.0001] *(nplts[1] +3)
            # based on parameters and config constants, set all sizes
            fig_widths[0] = samplelabels_space if samplelabels_space \
                            else config.HM_LEFT
            if show_samples_colorbar:
                fig_widths[1] = config.HM_Y_COLORBAR
            # heatmap width varies across plots, a nested list stores widths
            fig_widths[2] = [n_gs*config.HM_SQUARE_SIZE for n_gs in n_genes]
            if heatmap_width:
                fig_widths[2] = [heatmap_width*f_ws2 for f_ws2 in fig_widths[2]]
            if cluster_samples and show_samples_dendrogram:
                fig_widths[3] = config.HM_Y_DENDROGRAM
            if not hide_sum_plot:
                fig_widths[4] = config.G_HM_SUMPLOT_SIZE
            fig_widths[5] = config.HM_WSPACE * (nplts[1]-1)
            fig_widths[6] = config.HM_RIGHT

            fig_heights = [.0001] *(nplts[0] +3)
            fig_heights[0] = config.HM_TOP
            if cluster_genes and not hide_genes_dendrogram:
                fig_heights[1] = config.HM_X_DENDROGRAM
            if not hide_distance_bar:
                fig_heights[2] = config.HM_DISTANCE_BAR 
            fig_heights[3] = config.HM_SQUARE_SIZE *len(samples._names_noctrl) 
            if heatmap_height:
                fig_heights[3] *= heatmap_height
            if show_genes_colorbar:
                fig_heights[4] = config.HM_X_COLORBAR
            fig_heights[5] = config.HM_HSPACE * (nplts[0]-1)
            fig_heights[6] = genelabels_space if genelabels_space else \
                             config.HM_BOTTOM

            # duplicate height sizes and insert a spacer axis with size of top
            if self._down_mgs:
                nplts[0] = nplts[0] *2 +1
                hs = fig_heights
                ins = [config.G_HM_UPDOWN_SPACE_SIZE]
                fig_heights = hs[:-2] + ins + hs[1:-2] + hs[-2:]
                fig_heights[-2] = config.HM_HSPACE * (nplts[0]-1)
            return nplts, fig_widths, fig_heights

        # draw plot
        def do_plot(i):
            # get final width list for specific number of genes in plot
            this_fig_widths = fig_widths[:2] +[fig_widths[2][i]] +fig_widths[3:]
            width, height = sum(this_fig_widths), sum(fig_heights)
            fig, axes = util._init_figure(this_fig_widths, fig_heights, nplts, 
                                          (config.HM_WSPACE, config.HM_HSPACE))
            if self._down_mgs:
                [ax.set_visible(False) for ax in axes[4, :]]

            # set plot title
            if title and title not in (&#39;None&#39;, &#39;none&#39;, &#39;False&#39;, &#39;false&#39;, &#39;F&#39;, &#39;f&#39;):
                if title == True:
                    this_t = util._make_title(differential, metric,
                                              samples.name, t_name, 
                                              postf=&#39;per gene &#39;)
                    if display_genes:
                        this_t += &#39; - most similarity {} genes&#39;.format(display_genes) 
                    elif specific_genes is not None:
                        this_t += &#39; - list of specific marker genes&#39;
                    elif custom_target_genelist is not None:
                        this_t += &#39; - custom list of genes&#39;
                    
                elif title and isinstance(title, (list, tuple)):
                    this_t = title[i]
                else:
                    this_t = title
                if not pivot:
                    fig.suptitle(this_t, y=1- (config.HM_TOP/height)*.7,
                                 fontsize=config.FONTS)
                else:
                    row = 2 if not self._down_mgs else 7
                    axes[row, 0].set_ylabel(this_t, labelpad=10)
                
            # iterate over up and down plot-halfs
            for mgt, r in zip(self._mg_types, (0, 5)):
                sim, ctrl_sim, sim_trg = dat[mgt]

                # cluster genes/ samples and draw dendrograms
                if cluster_genes:
                    at = axes[r, 1] if not hide_genes_dendrogram else axes[r, 0]
                    order = util._heatmap_cluster(sim, &#39;top&#39;, at, &#39;columns&#39;)
                    sim, ctrl_sim = util._align_indices([sim, ctrl_sim], order)
                if cluster_samples:
                    at = axes[2+r, 2] if show_samples_dendrogram else axes[r, 0]
                    order = util._heatmap_cluster(sim, &#39;right&#39;, at, &#39;rows&#39;)
                    sim, sim_trg = util._align_indices([sim, sim_trg], order, 0)
                axes[r, 0].set_visible(False)

                # draw the distance bar 
                if not hide_distance_bar and metric == &#39;euclid&#39;:
                    # set order to order of sorted values in distance bar (ctrl)
                    if reorder_to_distance_bar:
                        order = ctrl_sim.iloc[0].sort_values().index
                        sim, ctrl_sim = util._align_indices([sim, ctrl_sim], order)
                        
                    bar_args = {&#39;vmin&#39;: low_db_cap, &#39;vmax&#39;: up_db_cap,
                                &#39;cmap&#39;: &#39;afmhot&#39;}
                    cb_lbl = config.EUCLID_ABS
                    # only draw colorbar legend if not absolute
                    if not hide_colorbar_legend and differential and mgt==&#39;up&#39;:
                        draw_cb = True
                    else:
                        draw_cb = False
                    # label of the distance bar on the left
                    ctrl_lbl = samples._ctrl if not hide_samplelabels else &#39;&#39;
                    util._plot_distance_bar(axes[1+r, :2], ctrl_sim, 
                                                  ctrl_lbl, bar_args, draw_cb, 
                                                  cb_lbl, fig, pivot, width, 
                                                  height)

                # setup heatmap x axis, including the colorbar
                xlbl = genes.set_index(&#39;ensg&#39;).reindex(sim.columns).name.values
                if show_genes_colorbar:
                    default = show_genes_colorbar.get(&#39;default&#39;, &#39;w&#39;) 
                    cols = [show_genes_colorbar.get(g, default) for g in xlbl]
                    cols = [c if is_color_like(c) else default for c in cols]
                else:
                    cols = None
                util._setup_heatmap_xy(&#39;x&#39;, axes[3+r, 1], xlbl, pivot,
                                      hide_genelabels, genelabels_size, cols) 

                # setup heatmap y axis, including the colorbar
                ylbl = sim.index.unique(2)[::-1]
                cols = samples.get_colors(ylbl) if show_samples_colorbar else \
                       None
                util._setup_heatmap_xy(&#39;y&#39;, axes[2+r, 0], ylbl, pivot, 
                                      hide_samplelabels, samplelabels_size, cols)
                if self._down_mgs:
                    tit = &#39;{} marker genes&#39;.format(mgt)
                    pad = 13 if not hide_distance_bar else 4
                    loc = &#39;right&#39; if not pivot else &#39;left&#39;
                    axes[2+r, 0].set_title(tit, loc=loc, fontweight=&#39;bold&#39;, 
                                           fontsize=config.FONTS, pad=pad)
                
                # draw summary plot on the right
                if not hide_sum_plot:
                    # general setup
                    ax = axes[2+r, 3]
                    ax.tick_params(labelbottom=True, bottom=True)
                    if pivot:
                        ax.tick_params(labelrotation=90)
                         
                    axes[3+r, 3].set_visible(False)
                    axes[1+r, 3].set_visible(False)
                    ax.set_axisbelow(True)
                    ax.xaxis.grid(alpha=0.8, linestyle=&#39;dashed&#39;)

                    # setup y axes
                    nsmps = sim_trg.shape[0]
                    ax.set_ylim(-.1, nsmps+.1)
                    yts = np.arange(nsmps-.5, -.5, -1)
                    ax.set_yticks(yts)

                    # setup x axes
                    ax.set_xlim(ts_lim)
                    if metric == &#39;euclid&#39; and differential:
                        lbl = config.EUCLID_DIFF
                    elif metric == &#39;euclid&#39; and not differential:
                        lbl = config.EUCLID_ABS
                        if not hide_distance_bar:
                            base = ctrl_sim.mean(1)
                            ax.vlines(base, 0, nsmps)
                            lbl += &#39;\n(line = base)&#39;
                    elif metric == &#39;intersect&#39;:
                        lbl = config.INTERSECT
                    if not pivot:
                        if (mgt==&#39;up&#39; and not self._down_mgs) or \
                        (mgt==&#39;down&#39; and self._down_mgs):
                            ax.set_xlabel(lbl)
                    else:
                        ax.get_yaxis().set_label_position(&#39;right&#39;)
                        ax.set_ylabel(lbl, rotation=90, labelpad=5)
                        
                    # if metric == &#39;euclid&#39;:
                    blue = config.colors[18] 
                    red = config.colors[14]
                    cols = [red if v &gt;0 else blue for v in sim_trg.values]
                    ax.barh(y=yts, width=sim_trg, color=cols)

                # draw heatmap
                ax = axes[2+r, 1]
                ax.set_yticks(np.arange(0, sim.shape[0]))
                ax.set_xticks(np.arange(0, sim.shape[1]))

                hm_args = {&#39;vmin&#39;: low_cap, &#39;vmax&#39;: up_cap}
                if metric == &#39;euclid&#39; and differential:
                        hm_args.update({&#39;cmap&#39;: &#39;RdBu_r&#39;})
                        cb_lbl = config.EUCLID_DIFF
                if metric == &#39;euclid&#39; and not differential:
                        hm_args.update({&#39;cmap&#39;: &#39;afmhot&#39;})
                        cb_lbl = config.EUCLID_ABS
                elif metric == &#39;intersect&#39;:
                        hm_args.update({&#39;cmap&#39;: config.RdBu_bin})
                        cb_lbl = config.INTERSECT_GENES
                im = ax.imshow(sim.values, aspect=&#39;auto&#39;, **hm_args)

                # setup heatmap colorbar legend and draw
                if mgt == &#39;up&#39; and not hide_colorbar_legend:    
                    # add a new axis for the colorbar
                    at = (config.CB_LEFT/width, 1- config.CB_TOP/height, 
                          config.CB_WIDTH/width, config.CB_HEIGHT/height)
                    cax = fig.add_axes(at)
                    cb = ax.figure.colorbar(im, cax=cax, orientation=&#39;horizontal&#39;) 
                    cb.ax.set_xlabel(cb_lbl)
                    cb.ax.get_xaxis().set_label_position(&#39;top&#39;)
                    bar_ticks = [hm_args[&#39;vmin&#39;], hm_args[&#39;vmax&#39;]]
                    cb.set_ticks(bar_ticks)                
                    if metric == &#39;intersect&#39;:
                        bar_ticks = (&#39;mismatch&#39;, &#39;match&#39;)
                    cb.ax.set_xticklabels(bar_ticks)
                    if pivot:
                        cb.ax.tick_params(labelrotation=90)
                dat[mgt] = sim, ctrl_sim, sim_trg
            return fig, axes, dat
            
        spacer.info(&#39;\n\n&#39; + log_plot)
        logger.info(&#39;Plot: {} &amp; {}&#39;.format(self.name, samples.name))
        genes = _check_args()
        data = get_data()
        up_cap, low_cap, up_db_cap, low_db_cap, ts_lim, n_genes = get_caps()

        nplts, fig_widths, fig_heights = get_plot_sizes()
        spacer.info(&#39;&#39;)
        logger.info(&#39;Drawing...&#39;)
        if filename:
            filename, pp = util._open_file(filename)
            ftype = filename[-4:]
        ret = {}
        for i, (t_name, dat) in enumerate(data.items()):
            fig, axes, dat = do_plot(i)
            spacer.info(&#39;{}/{} --- {}&#39;.format(i+1, len(data), t_name))
            if plt_show:
                plt.show()
            ret.update({t_name: (fig, axes, dat)})
            if filename:
                this_png_fn = &#39;{}_{}{}&#39;.format(filename[:-4], t_name, ftype)
                util._save_file(fig, filename=this_png_fn, pp=pp)
        if filename:
            if pp:
                pp.close()
            logger.info(&#39;Plots saved at {}/{}\n\n&#39;
                        .format(os.path.abspath(os.curdir), filename))
        return ret 

    def ranked_similarity_barplot(self,
                                  # plot data
                                  samples,
                                  metric = None, 
                                  differential = True,
                                  display_markergenes = &#39;mean&#39;,
                                  n_targets = 16,
                                  display_negative = False,
                                  # data ordering
                                  rank_samples = False,
                                  # general settings
                                  pivot = False,
                                  xlim_range = None,
                                  targetlabels_space = None,
                                  targetlabels_size = None,
                                  colored_bars = False,
                                  spines = False,
                                  title = True,
                                  # show/ hide elements
                                  hide_targetlabels = False,
                                  hide_colorbar = False,
                                  hide_base_lines = False,
                                  # others
                                  filename = &#39;ranked_similarity_bp&#39;,
                                  plt_show = False,
                                  **kwargs):
        &#34;&#34;&#34;Plot the ranked similarity of the samples with the targets in a 
        barplot

            Sort the similarity values of the samples and targets to identify
            the dominating effects in the samples. Two different metrics can be 
            picked to assess similarity: &#39;euclid&#39; for expression inputs or 
            &#39;intersect&#39; for comparison based on diff. genes/ marker genes.
            Differential and absolute similarity values are available 
            options for investagting the change in similarity.

        Args:
            =================== Plot data options ===================
            samples (samples): the data to rank similariity for.
            metric (str, optional): the similarity metric to use. Valid 
                options are &#39;euclid&#39;, &#39;intersect&#39;, &#39;cosine&#39;, &#39;pearson&#39;. Defaults 
                to None.&#39;euclid&#39; shows the mean euclidean distance towards the 
                target marker genes expression levels and requires `expression` 
                input for samples and targets. &#39;intersect&#39; will show the overlap 
                between diff. sample genes and target marker genes requiring 
                gene list input. &#39;cosine&#39; will compute the cosine similarity, 
                &#39;pearson&#39; the Pearson correlation coefficient. More details in
                publication. When None, set to &#39;cosine&#39; when expression input 
                was passed, or &#39;intersect&#39; when gene list data was passed.
            differential (bool, optional): plot the differential (change in)
                similarity from the untreated-,/ base-sample, or. the control 
                to other samples. Defaults to True. Requires a control to be 
                passed for the expression-based metrics. Cannot be False for 
                &#39;intersect&#39;-metric.
            display_markergenes (str, optional): specify the group of 
                marker genes to display similarity for. Defaults to &#39;mean&#39;. 
                Valid options are &#39;mean&#39;, &#39;up&#39;, &#39;down&#39;. Relevent when targets 
                are initiated with down-marker genes.
            n_targets (int, optional): the number of targets to display in each
                plot. Defaults to 16. 
            display_negative (bool, optional): display the most negative values 
                on the bottom half of the bar plot. Defaults to False. 

            =================== data ordering options ===================
            rank_samples (bool, optional): Rank the samples based on their most 
                positive value and generate the barplots in the same order. 
                Defaults to False. When False, use the default samples order.
            
            =================== general visual options ===================
            pivot (bool, optional): pivot the barplot by 90 degrees. 
                Defaults to False. Useful for fitting the barplot on a canvas. 
            xlim_range (list, optional): Define the lower- and upper 
                x-limits for the barplot. Defaults to None. The list is 
                interpreted as, [lower_limit, upper_limit]. When None, the 
                x-limits are defined by adding 15% to the minimum and maximum
                values. 
            targetlabels_space (float, optional): define the size in inches
                to reserve for target labels, here, the white space on the
                left. Defaults to None. When None, refer to the value set in 
                config.BP_LEFT.
            targetlabels_size (float, optional): multiplier for adjusting 
                target label size. Defaults to None. Useful for very high or low 
                number of targets.
            colored_bars (bool, optional): colorize negative values in blue, 
                positive ones in red. Defaults to False.
            spines (bool, optional): in addition to the bottom and left spines,
                plot the top and right ones. Defaults to False.
            title (bool, str, list optional): the plot title to set. Defaults to 
                True. For True, infer the title based on plot data inputs and 
                targets/ samples name attribute. Text input will be set as 
                the general title, False hides the title. A list of str will be
                set according to the list of plots.
            kwargs: modify the constants defined in config. This is used as an 
                advanced adjustment of plot element sizes and the minimum 
                required marker genes detection proportion. The barplots may be
                adjusted by the following paramters: DROP_TARGET_DETEC_THR,
                BP_LEFT, BP_TOP, BP_RIGHT, BP_BOTTOM, BP_Y_COLORBAR, 
                BP_BARSPACE, BP_BARWIDTH_SIZE.

            =================== hide/show plot elements ===================
            hide_targetlabels (bool, optional): Do not plot the target labels 
                at the left. Defaults to False.
            hide_colorbar (bool, optional): Do not plot the targets colorbar on 
                the left of the barplot. Defaults to False. 
            hide_base_lines (bool, optional): Do not show the lines marking 
                the absolute simialrity of the control, i.e. the base line. 
            
            =================== others ===================
            filename (str, optional): the filename for saving the figure.
                Defaults to &#39;ranked_similarity_bp.png&#39;. Supported filename 
                endings are .png and .pdf. If filename does not end with 
                these, the filetype is retrieved from conifg.SAVE_FORMAT.
                If None, the plot is not saved.
            plt_show (bool, optional): directly show each created plot in a new
                window. Defaults to False.
            
        &#34;&#34;&#34;
        # check user input for errors and incompatibilities around `metric` arg
        def _check_args():
            nonlocal metric
            nonlocal differential
            nonlocal n_targets
            nonlocal display_markergenes

            # check general basic input requirements
            r = util._check_args(self, samples, metric, differential,  
                                 display_markergenes=display_markergenes)
            metric, differential, _, _, _, _, display_markergenes = r
            if not n_targets or n_targets &gt; len(self):
                n_targets = len(self)
                logger.warning(&#39;The number of targets `n_targets` was None or &#39;
                               &#39;greater the length of the targets. Set to all &#39;
                               &#39;target elements ({}).&#39;.format(len(self)))
            config._update_consts(kwargs)            
            logger.info(&#39;Arguments passed. Getting data now ...&#39;)

        # get the target similarity data for plotting, pick the targets
        def get_data():
            sim, ctrl_sim = self._get_similarity(samples, metric, 
                                                 differential=differential,
                                                 drop_ctrl=differential)
            sim = sim.xs(display_markergenes, 1, 0)
            if rank_samples:
                if differential:
                    order = sim.max(1).sort_values(ascending=False).index
                else:
                    order = sim.min(1).sort_values().index
                sim = sim.reindex(order)
            
            # slice that selects the targets in the ranking
            drop = slice(int(n_targets/2), -int(n_targets/2)) if display_negative \
                   else slice(-1, n_targets-1, -1)
            
            asc = True if metric == &#39;euclid&#39; and not differential else False
            data = dict.fromkeys(sim.index, None)
            def sel_trgs(smp_row):                
                trgs = smp_row.iloc[0].sort_values(ascending=asc)
                data[trgs.name] = trgs.drop(trgs.index[drop])
            sim.groupby(level=0).apply(sel_trgs)
            return data, ctrl_sim
        
        # get plot global limits
        def get_caps():
            if xlim_range is not None:
                return xlim_range
            else:
                maxi = max([trg_vals.max() for trg_vals in list(data.values())])
                mini = min([trg_vals.min() for trg_vals in list(data.values())])
                ext = max([abs(maxi), abs(mini)]) *.15
                lims = [mini -ext, maxi +ext]
                if lims[0]&gt;=0 and lims[1]&gt;=0:
                    lims[lims.index(min(lims))] = 0
                elif lims[0]&lt;=0 and lims[1]&lt;=0:
                    lims[lims.index(max(lims))] = 0
                return lims

        # built 2 lists with widths and heights in inches of every axes
        def get_plot_sizes():
            fig_widths = [.0001] *5
            fig_widths[0] = targetlabels_space if targetlabels_space else \
                            config.BP_LEFT   
            if not hide_colorbar:
                fig_widths[1] = config.BP_Y_COLORBAR
            fig_widths[2] = config.BP_BARSPACE
            fig_widths[3] = .04
            fig_widths[4] = config.BP_RIGHT
            
            fig_heights = [.0001] *4
            fig_heights[0] = config.BP_TOP
            fig_heights[1] = config.BP_BARWIDTH_SIZE *n_targets
            fig_heights[2] = 0
            fig_heights[3] = config.BP_BOTTOM
            return fig_widths, fig_heights
        
        # draw plot
        def do_plot(i, dat):
            height, width = sum(fig_heights), sum(fig_widths)
            fig, axes = util._init_figure(fig_widths, fig_heights, (1, 2), 
                                          (.04,0))
            ax = axes[1]
            if spines:
                ax.spines[&#39;right&#39;].set_visible(True)
                ax.spines[&#39;top&#39;].set_visible(True)

            # set plot title
            if title and title not in (&#39;None&#39;, &#39;none&#39;, &#39;False&#39;, &#39;false&#39;, &#39;F&#39;, &#39;f&#39;):
                if title == True:
                    this_t = util._make_title(differential, metric, s_name, 
                                              self.name, pref=&#39;ranked &#39;)
                elif title and isinstance(title, (list, tuple)):
                    this_t = title[i]
                else:
                    this_t = title
                if not pivot:
                    fig.suptitle(this_t, y=1- (config.BP_TOP/height)*.6,
                                 fontsize=config.FONTS)
                else:
                    ax.get_yaxis().set_label_position(&#39;right&#39;)
                    ax.set_ylabel(this_t, rotation=-90, labelpad=25)

            # setup y axis including the colorbar
            ax.spines[&#39;left&#39;].set_visible(True)
            n = dat.shape[0] if not display_negative else dat.shape[0] +1
            ylim = n, -1
            yts = np.arange(n)
            [(ax.set_ylim(ylim), ax.set_yticks(yts)) for ax in axes]
            ylbls = dat.index.tolist()
            if not hide_colorbar:
                cols = self.get_colors(ylbls)
                if display_negative:
                    cols.insert(int(len(ylbls)/2), &#39;w&#39;)
                axes[0].bar(0, 1, color=cols, bottom=yts-.5)
            # if negative, insert a gab between the two groups 
            if display_negative:
                ylbls.insert(int(len(ylbls)/2), &#39;&#39;)
                dat = dat.append(pd.Series(0, [&#39;&#39;])).reindex(ylbls)
                # delta half-height/ width of split line between pos. &amp; neg. group
                d_hh = (.01/fig_heights[1]) /2
                d_wh = (.03/fig_widths[2])
                line_args = {&#39;xdata&#39;: (-d_wh, d_wh), &#39;transform&#39;: ax.transAxes, 
                             &#39;clip_on&#39;: False, &#39;color&#39;: &#39;k&#39;}
                ax.add_line(Line2D(ydata=(.5-d_hh*1.25, .5-d_hh*.25), **line_args))
                ax.add_line(Line2D(ydata=(.5+d_hh*.25, .5+d_hh*1.25), **line_args))
            if not hide_targetlabels:
                axes[0].tick_params(labelleft=True)
                fs = config.FONTS*targetlabels_size if targetlabels_size else \
                     config.FONTS
                if not pivot:
                    axes[0].set_yticklabels(ylbls, fontsize=fs)
                else:
                    axes[0].set_yticklabels(ylbls, rotation=-45, ha=&#39;right&#39;, 
                                            x=-.5, rotation_mode=&#39;anchor&#39;, 
                                            fontsize=fs)
            
            # setup x axis
            xlim = lims
            if not pivot:
                ax.spines[&#39;bottom&#39;].set_visible(True)
                ax.tick_params(bottom=True, labelbottom=True)
            else:
                ax.spines[&#39;top&#39;].set_visible(True)
                ax.tick_params(top=True, labeltop=True, labelrotation=-90)
                ax.xaxis.set_label_position(&#39;top&#39;)
            ax.set_xlim(xlim)
            ax.set_axisbelow(True)
            ax.xaxis.grid(alpha=0.8, linestyle=&#39;dashed&#39;)

            if metric == &#39;euclid&#39; and differential:
                xlbl = config.EUCLID_DIFF
            elif metric == &#39;euclid&#39; and not differential:
                xlbl = config.EUCLID_ABS
            elif metric == &#39;cosine&#39; and differential:
                xlbl = config.COSINE_DIFF
            elif metric == &#39;cosine&#39; and not differential:
                xlbl = config.COSINE_ABS
            elif metric == &#39;pearson&#39; and differential:
                xlbl = config.PEARSON_DIFF
            elif metric == &#39;pearson&#39; and not differential:
                xlbl = config.PEARSON_ABS
            elif metric == &#39;intersect&#39;:
                xlbl = config.INTERSECT

            # for absolute euclid sim., mark the untreated base if available
            if not differential and samples._ctrl and not hide_base_lines:
                xs = ctrl_sim.loc[samples._ctrl, display_markergenes]
                xs = xs.reindex(ylbls, axis=1)
                ax.vlines(xs, yts-.4, yts+.4, linewidth=.5)
                xlbl += &#39;\n(line = base)&#39;
            ax.set_xlabel(xlbl, labelpad=5)

            if not colored_bars:
                cols = config.colors[19]
            else:
                blue = config.colors[18] 
                red = config.colors[14]
                cols = [red if v &gt;0 else blue for v in dat.values]
                
            ax.barh(yts, dat, color=cols)
            return fig, axes

        spacer.info(&#39;\n\n&#39; + log_plot)
        logger.info(&#39;Plot: {} &amp; {}&#39;.format(self.name, samples.name))
        _check_args()
        data, ctrl_sim = get_data()
        lims = get_caps()

        fig_widths, fig_heights = get_plot_sizes()
        spacer.info(&#39;&#39;)
        logger.info(&#39;Drawing...&#39;)
        if filename:
            filename, pp = util._open_file(filename)
            ftype = filename[-4:]
        ret = {}
        for i, (s_name, dat) in enumerate(data.items()):
            fig, axes = do_plot(i, dat)
            spacer.info(&#39;{}/{} --- {}&#39;.format(i+1, len(data), s_name))
            if plt_show:
                plt.show()
            ret.update({s_name: (fig, axes, dat)})
            if filename:
                this_png_fn = &#39;{}_{}.{}&#39;.format(filename[:-4], s_name, ftype)
                util._save_file(fig, filename=this_png_fn, pp=pp)
        if filename:
            if pp:
                pp.close()
            logger.info(&#39;Plots saved at {}/{}\n\n&#39;
                        .format(os.path.abspath(os.curdir), filename))
        return ret </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>DPre.main._differential._differential</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="main.targets.targets.gene_similarity_heatmap"><code class="name flex">
<span>def <span class="ident">gene_similarity_heatmap</span></span>(<span>self, samples, metric=None, differential=True, display_genes='variant', gene_number=45, specific_genes=None, custom_target_genelist=None, cluster_genes=False, cluster_samples=False, reorder_to_distance_bar=False, pivot=False, heatmap_width=None, heatmap_height=None, heatmap_range=None, distance_bar_range=None, sum_plot_range=None, genelabels_space=None, genelabels_size=None, samplelabels_size=None, samplelabels_space=None, title=True, hide_colorbar_legend=False, hide_distance_bar=False, hide_sum_plot=False, hide_genelabels=False, hide_genes_dendrogram=False, show_genes_colorbar=None, hide_samplelabels=False, show_samples_dendrogram=False, show_samples_colorbar=False, filename='gene_similarity_hm', plt_show=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the single-gene similarities of the samples with the targets
in an array of heatmaps.</p>
<p>This function reveals the drivers behind target similarity shifts.
Besides various gene extraction options, a genelist can be passed to
investigate specific similarity changes. On the right of the
heatmap, a bar plot visualizes a summery of the gene values.
Two different metrics can be picked to assess similarity:
'euclid' for expression inputs or 'intersect' for comparison based
on diff. genes/ marker genes. Differential and absolute gene
similarity values are available options for investagting the change
in similarity. When targets were initiated with down-marker genes,
a seperate heatmap for each marker gene type is drawn.</p>
<h2 id="args">Args</h2>
<dl>
<dt>=================== Plot data options ===================</dt>
<dt><strong><code>samples</code></strong> :&ensp;<code>samples</code></dt>
<dd>the data to rate similarity for.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the similarity metric to use. Valid
options are 'euclid', 'intersect', 'cosine', 'pearson'. Defaults
to None.'euclid' shows the mean euclidean distance towards the
target marker genes expression levels and requires <code>expression</code>
input for samples and targets. 'intersect' will show the overlap
between diff. sample genes and target marker genes requiring
gene list input. 'cosine' will compute the cosine similarity,
'pearson' the Pearson correlation coefficient. More details in
publication. When None, set to 'cosine' when expression input
was passed, or 'intersect' when gene list data was passed.</dd>
<dt><strong><code>differential</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>plot the differential (change in)
similarity from the untreated-,/ base-sample, or. the control
to other samples. Defaults to True. Requires a control to be
passed for the expression-based metrics. Cannot be False for
'intersect'-metric.</dd>
<dt><strong><code>display_genes</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Extract a specific set of
marker genes to display for each target. Defaults to 'variant'.
Valid options are 'variant', 'increasing', 'decreasing' when
differential True, and 'variant', 'distant', 'similar' for
differential False. To identify sample specific effects, these
metrics will sort according to outlaying sample values rather
then overall high/ low/ increasing etc. values. This is one of
the 3 gene selection options to choose from.</dd>
<dt><strong><code>gene_number</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of genes to plot for the
'display_genes' option. Defaults to 45. This option is
ignored for the two other gene selection options
'specific_genes' and 'custom_target_genelist'. </dd>
<dt><strong><code>specific_genes</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Specify the marker genes to
display in a list of gene names. Defaults to None. A gene
from this list is only displayed if it is a marker gene of
the specifc target and detected in the samples. This option can
be used idependently or in combination with 'display_genes' for
adding specific genes of interest to the extracted ones. Genes
are annotated referencing enseble v.96.</dd>
<dt><strong><code>custom_target_genelist</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Specify a custom list
of gene names to display similarity for. Defaults to None.
Currently this option is only implemented for the 'euclid'
similarity metric. The passed genelist will be used for all
targets. In contrast to 'specific_genes', the genes only need to
be detected in the targets instead of qualifying as specific
target marker genes. Still, genes need to be detected in the
samples. Genes are annotated referencing enseble v.96.</dd>
<dt>=================== data ordering options ===================</dt>
<dt><strong><code>cluster_genes</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>cluster genes using the
euclidean distance. Defaults to False.</dd>
<dt><strong><code>cluster_samples</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>cluster samples using the
euclidean distance. Defaults to False.</dd>
<dt><strong><code>reorder_to_distance_bar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>reorder the genes
from lowest to highest base distance. Defaults to False.
Cannot be True when
'cluster_genes' is True aswell.
For details, check the 'hide_distance_bar' argument. </dd>
<dt>=================== general visual options ===================</dt>
<dt><strong><code>pivot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>pivot the heatmap by 90 degrees. Defaults
to False. Useful for fitting the heatmap on a canvas. </dd>
<dt><strong><code>heatmap_width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>multiplier to stretch/ squeeze
the heatmap squares in x direction. Defaults to None. For
pivot = True this paramter controls the height.
Useful for very low or high number of genes. </dd>
<dt><strong><code>heatmap_height</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>multiplier to stretch/ squeeze
the heatmap squares in y direction. Defaults to None. For
pivot = True this paramter controls the width.
Useful for very low or high number of samples.</dd>
<dt><strong><code>distance_bar_range</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Define the range of values
that form the colormap for the distance bar. Defaults to
None. The list is interpreted as, [lower_limit, upper_limit].
When None, the edges are defined to cover 90% of occuring values
ignoring outlayers. </dd>
<dt><strong><code>sum_plot_range</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Define the lower- and upper
x-limits for the summary plot. Defaults to None. The list is
interpreted as, [lower_limit, upper_limit]. When None, the
x-limits are defined by adding 15% to the minimum and maximum
values. </dd>
<dt><strong><code>genelabels_space</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>define the size in inches
to reserve for gene labels, here, the white space on the
bottom. Defaults to None. When None, refer to the values set in
config.HM_BOTTOM.</dd>
<dt><strong><code>samplelabels_space</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>define the size in inches
to reserve for sample labels, here, the white space on the
left. Defaults to None. When None, refer to the value set in
config.HM_LEFT.</dd>
<dt><strong><code>genelabels_size</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>multiplier for adjusting gene
label size. Defaults to None. Useful for very high or low
number of genes.</dd>
<dt><strong><code>samplelabels_size</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>multiplier for adjusting
sample label size. Defaults to None. Useful for very high or low
number of samples.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>bool</code>, <code>str</code>, optional</dt>
<dd>the plot title to set. Defaults to
True. For True, infer the title based on plot data inputs and
targets/ samples name attribute. Text input will be set as
the general title, False hides the title. A list of str will be
set according to the list of plots.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>modify the constants defined in config. This is used as an
advanced adjustment of plot element sizes and the minimum
required marker genes detection proportion. The heatmaps may be
adjusted by the following paramters: DROP_TARGET_DETEC_THR,
HM_LEFT, HM_TOP, HM_RIGHT, HM_BOTTOM, HM_WSPACE,
HM_HSPACE, HM_Y_COLORBAR, HM_X_COLORBAR, HM_DISTANCE_BAR,
HM_Y_DENDROGRAM, HM_X_DENDROGRAM, HM_SQUARE_SIZE,
G_HM_SUMPLOT_SIZEG_HM_UPDOWN_SPACE_SIZE, CB_LEFT,
CB_LEFT_SEC, CB_TOP, CB_WIDTH,
CB_HEIGHT.</dd>
<dt>=================== hide/show plot elements ===================</dt>
<dt><strong><code>hide_colorbar_legend</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the colorbar
legend. Defaults to False. Applies for all colorbar_legends.</dd>
<dt><strong><code>hide_distance_bar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the distance
bar on top of the heatmap. Defaults to False. When True, the
control will appear in the main heatmap. For the expression-
based metrics, this bar visualizes the absolute similarity of
the control with the targets. For the 'intersect' metric, the
number of target marker genes is shown. Defaults to False.</dd>
<dt><strong><code>hide_sum_plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not generate the summary plot on
the right visualizing the samples genes. Defualts to False.
This plot shows the summarized similarity of all genes. It
computes like the target similarty, but limited to the displayed
genes.</dd>
<dt><strong><code>hide_genelabels</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the gene
labels at the bottom. Defaults to False.</dd>
<dt><strong><code>hide_genes_dendrogram</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the
genes dendrogram from clustering. Defaults to False.
Requires 'cluster_genes' to be True. </dd>
<dt><strong><code>show_genes_colorbar</code></strong> :&ensp;<code>dict</code>, <code>bool</code>, optional</dt>
<dd>Plot a genes colorbar on
the bottom of the heatmap. Defaults to None. A dictionary
should map gene names to colors. Mappings for genes not
displayed in the plot are ignored. The color for M=missing gene
keys is set to white. When, True and <code>specifc_genes</code> passed,
the passed genes will be set to config.colors[1] (green). </dd>
<dt><strong><code>hide_samplelabels</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the sample
labels at the left. Defaults to False.</dd>
<dt><strong><code>show_samples_dendrogram</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Plot the samples
dendrogram from clustering. Defaults to False. Requires
'cluster_samples' to be True.</dd>
<dt><strong><code>show_samples_colorbar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Plot the samples
colorbar on the left of the heatmap. Defaults to False.
When colors are not set for the targets using the
set_colors() function, colors are set to white. </dd>
<dt>=================== others ===================</dt>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the filename for saving the figure.
Defaults to 'gene_similarity_hm.pdf'. Supported filename
endings are .png and .pdf. If filename does not end with
these, the filetype is retrieved from conifg.SAVE_FORMAT.
If None, the plot is not saved.</dd>
<dt><strong><code>plt_show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>directly show each created plot in a new
window. Defaults to False.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def gene_similarity_heatmap(self,
                            # plot data
                            samples,  
                            metric = None,
                            differential = True,
                            display_genes = &#39;variant&#39;,
                            gene_number = 45,
                            specific_genes = None,
                            custom_target_genelist = None,
                            # data ordering
                            cluster_genes = False,
                            cluster_samples = False,
                            reorder_to_distance_bar = False,
                            # general settings
                            pivot = False,
                            heatmap_width = None,
                            heatmap_height = None,
                            heatmap_range = None,
                            distance_bar_range = None,
                            sum_plot_range = None,
                            genelabels_space = None,
                            genelabels_size = None,
                            samplelabels_size = None,
                            samplelabels_space = None,
                            title = True, 
                            # show/ hide elements 
                            hide_colorbar_legend = False,
                            hide_distance_bar = False,
                            hide_sum_plot = False,
                            hide_genelabels = False,
                            hide_genes_dendrogram = False,
                            show_genes_colorbar = None,
                            hide_samplelabels = False,
                            show_samples_dendrogram = False,
                            show_samples_colorbar = False,
                            # others
                            filename = &#39;gene_similarity_hm&#39;,
                            plt_show = False,
                            **kwargs):
    &#34;&#34;&#34;Plot the single-gene similarities of the samples with the targets 
    in an array of heatmaps.

    This function reveals the drivers behind target similarity shifts. 
    Besides various gene extraction options, a genelist can be passed to 
    investigate specific similarity changes. On the right of the 
    heatmap, a bar plot visualizes a summery of the gene values.
    Two different metrics can be picked to assess similarity: 
    &#39;euclid&#39; for expression inputs or &#39;intersect&#39; for comparison based 
    on diff. genes/ marker genes. Differential and absolute gene
    similarity values are available options for investagting the change 
    in similarity. When targets were initiated with down-marker genes,
    a seperate heatmap for each marker gene type is drawn.

    Args:
        =================== Plot data options ===================
        samples (samples): the data to rate similarity for.
        metric (str, optional): the similarity metric to use. Valid 
            options are &#39;euclid&#39;, &#39;intersect&#39;, &#39;cosine&#39;, &#39;pearson&#39;. Defaults 
            to None.&#39;euclid&#39; shows the mean euclidean distance towards the 
            target marker genes expression levels and requires `expression` 
            input for samples and targets. &#39;intersect&#39; will show the overlap 
            between diff. sample genes and target marker genes requiring 
            gene list input. &#39;cosine&#39; will compute the cosine similarity, 
            &#39;pearson&#39; the Pearson correlation coefficient. More details in
            publication. When None, set to &#39;cosine&#39; when expression input 
            was passed, or &#39;intersect&#39; when gene list data was passed.
        differential (bool, optional): plot the differential (change in)
            similarity from the untreated-,/ base-sample, or. the control 
            to other samples. Defaults to True. Requires a control to be 
            passed for the expression-based metrics. Cannot be False for 
            &#39;intersect&#39;-metric.
        display_genes (str, optional): Extract a specific set of 
            marker genes to display for each target. Defaults to &#39;variant&#39;. 
            Valid options are &#39;variant&#39;, &#39;increasing&#39;, &#39;decreasing&#39; when 
            differential True, and &#39;variant&#39;, &#39;distant&#39;, &#39;similar&#39; for 
            differential False. To identify sample specific effects, these 
            metrics will sort according to outlaying sample values rather 
            then overall high/ low/ increasing etc. values. This is one of 
            the 3 gene selection options to choose from.
        gene_number (int, optional): The number of genes to plot for the 
            &#39;display_genes&#39; option. Defaults to 45. This option is 
            ignored for the two other gene selection options 
            &#39;specific_genes&#39; and &#39;custom_target_genelist&#39;. 
        specific_genes (list, optional): Specify the marker genes to 
            display in a list of gene names. Defaults to None. A gene 
            from this list is only displayed if it is a marker gene of 
            the specifc target and detected in the samples. This option can 
            be used idependently or in combination with &#39;display_genes&#39; for 
            adding specific genes of interest to the extracted ones. Genes 
            are annotated referencing enseble v.96.
        custom_target_genelist (list, optional): Specify a custom list 
            of gene names to display similarity for. Defaults to None. 
            Currently this option is only implemented for the &#39;euclid&#39; 
            similarity metric. The passed genelist will be used for all 
            targets. In contrast to &#39;specific_genes&#39;, the genes only need to 
            be detected in the targets instead of qualifying as specific 
            target marker genes. Still, genes need to be detected in the 
            samples. Genes are annotated referencing enseble v.96.
        
        =================== data ordering options ===================
        cluster_genes (bool, optional): cluster genes using the 
            euclidean distance. Defaults to False.
        cluster_samples (bool, optional): cluster samples using the 
            euclidean distance. Defaults to False.
        reorder_to_distance_bar (bool, optional): reorder the genes
            from lowest to highest base distance. Defaults to False. 
            Cannot be True when  &#39;cluster_genes&#39; is True aswell.
            For details, check the &#39;hide_distance_bar&#39; argument. 

        =================== general visual options ===================
        pivot (bool, optional): pivot the heatmap by 90 degrees. Defaults 
            to False. Useful for fitting the heatmap on a canvas. 
        heatmap_width (float, optional): multiplier to stretch/ squeeze 
            the heatmap squares in x direction. Defaults to None. For 
            pivot = True this paramter controls the height. 
            Useful for very low or high number of genes. 
        heatmap_height (float, optional): multiplier to stretch/ squeeze 
            the heatmap squares in y direction. Defaults to None. For 
            pivot = True this paramter controls the width.
            Useful for very low or high number of samples.
        distance_bar_range (list, optional): Define the range of values
            that form the colormap for the distance bar. Defaults to
            None. The list is interpreted as, [lower_limit, upper_limit]. 
            When None, the edges are defined to cover 90% of occuring values 
            ignoring outlayers. 
        sum_plot_range (list, optional): Define the lower- and upper 
            x-limits for the summary plot. Defaults to None. The list is 
            interpreted as, [lower_limit, upper_limit]. When None, the 
            x-limits are defined by adding 15% to the minimum and maximum
            values. 
        genelabels_space (float, optional): define the size in inches
            to reserve for gene labels, here, the white space on the
            bottom. Defaults to None. When None, refer to the values set in 
            config.HM_BOTTOM.
        samplelabels_space (float, optional): define the size in inches
            to reserve for sample labels, here, the white space on the
            left. Defaults to None. When None, refer to the value set in 
            config.HM_LEFT.
        genelabels_size (float, optional): multiplier for adjusting gene 
            label size. Defaults to None. Useful for very high or low 
            number of genes.
        samplelabels_size (float, optional): multiplier for adjusting 
            sample label size. Defaults to None. Useful for very high or low 
            number of samples.
        title (bool, str, optional): the plot title to set. Defaults to 
            True. For True, infer the title based on plot data inputs and 
            targets/ samples name attribute. Text input will be set as 
            the general title, False hides the title. A list of str will be
            set according to the list of plots.
        kwargs: modify the constants defined in config. This is used as an 
            advanced adjustment of plot element sizes and the minimum 
            required marker genes detection proportion. The heatmaps may be
            adjusted by the following paramters: DROP_TARGET_DETEC_THR,
            HM_LEFT, HM_TOP, HM_RIGHT, HM_BOTTOM, HM_WSPACE, 
            HM_HSPACE, HM_Y_COLORBAR, HM_X_COLORBAR, HM_DISTANCE_BAR, 
            HM_Y_DENDROGRAM, HM_X_DENDROGRAM, HM_SQUARE_SIZE, 
            G_HM_SUMPLOT_SIZEG_HM_UPDOWN_SPACE_SIZE, CB_LEFT, 
            CB_LEFT_SEC, CB_TOP, CB_WIDTH, 
            CB_HEIGHT.
        
        =================== hide/show plot elements ===================
        hide_colorbar_legend (bool, optional): Do not plot the colorbar 
            legend. Defaults to False. Applies for all colorbar_legends.
        hide_distance_bar (bool, optional): Do not plot the distance 
            bar on top of the heatmap. Defaults to False. When True, the 
            control will appear in the main heatmap. For the expression-
            based metrics, this bar visualizes the absolute similarity of 
            the control with the targets. For the &#39;intersect&#39; metric, the 
            number of target marker genes is shown. Defaults to False.
        hide_sum_plot (bool, optional): Do not generate the summary plot on
            the right visualizing the samples genes. Defualts to False.
            This plot shows the summarized similarity of all genes. It 
            computes like the target similarty, but limited to the displayed
            genes.
        hide_genelabels (bool, optional): Do not plot the gene 
            labels at the bottom. Defaults to False.
        hide_genes_dendrogram (bool, optional): Do not plot the 
            genes dendrogram from clustering. Defaults to False. 
            Requires &#39;cluster_genes&#39; to be True. 
        show_genes_colorbar (dict, bool, optional): Plot a genes colorbar on 
            the bottom of the heatmap. Defaults to None. A dictionary 
            should map gene names to colors. Mappings for genes not 
            displayed in the plot are ignored. The color for M=missing gene 
            keys is set to white. When, True and `specifc_genes` passed,
            the passed genes will be set to config.colors[1] (green). 
        hide_samplelabels (bool, optional): Do not plot the sample 
            labels at the left. Defaults to False.
        show_samples_dendrogram (bool, optional): Plot the samples 
            dendrogram from clustering. Defaults to False. Requires 
            &#39;cluster_samples&#39; to be True.
        show_samples_colorbar (bool, optional): Plot the samples
            colorbar on the left of the heatmap. Defaults to False. 
            When colors are not set for the targets using the 
            set_colors() function, colors are set to white. 

        =================== others ===================
        filename (str, optional): the filename for saving the figure.
            Defaults to &#39;gene_similarity_hm.pdf&#39;. Supported filename 
            endings are .png and .pdf. If filename does not end with 
            these, the filetype is retrieved from conifg.SAVE_FORMAT.
            If None, the plot is not saved.
        plt_show (bool, optional): directly show each created plot in a new
            window. Defaults to False.
    &#34;&#34;&#34;
    # check user input for errors and incompatibilities
    def _check_args():
        nonlocal metric
        nonlocal differential
        nonlocal display_genes
        nonlocal specific_genes
        nonlocal custom_target_genelist

        nonlocal hide_distance_bar
        nonlocal reorder_to_distance_bar
        nonlocal cluster_genes
        nonlocal show_genes_colorbar
        nonlocal distance_bar_range

        # check general basic input requirements
        r = util._check_args(self, samples, metric, differential, 
                             hide_distance_bar, reorder_to_distance_bar, 
                             distance_bar_range, cluster_genes)
        if r[0] == &#39;cosine&#39;:
            # default for per gene cannot be cosine, change to euclid here
            metric = &#39;euclid&#39;
        _, differential, hide_distance_bar, reorder_to_distance_bar, \
        distance_bar_range, cluster_genes, _ = r

        # check main data input
        if self._species not in [&#39;human&#39;, &#39;mouse&#39;]:
            logger.info(&#39;&#39;)
            logger.error(&#39;Invalid input for species: `{}`. Valid are `mouse` &#39;
                         &#39;and `human`. Initate targets with these species &#39; 
                         &#39;to use this function.&#39;.format(self._species))
            sys.exit(1)
        if metric == &#39;intersect&#39; and not hide_distance_bar:
            hide_distance_bar = True
            logger.warning(&#39;For the intersect metric, there is no distance&#39;
                           &#39;bar. `hide_distance_bar` was set to True.&#39;)
        if custom_target_genelist is not None and metric == &#39;intersect&#39;:
            logger.error(&#39;The `custom_target_genelist` option is &#39;
                         &#39;currentily not implemented for the similarity &#39;
                         &#39;metric `intersect`. Please choose an alternative &#39;
                         &#39;gene selection option.&#39;)
            sys.exit(1)
        if custom_target_genelist is not None and display_genes:
            display_genes = None
            logger.info(&#39;Both `display_genes` and &#39;
                        &#39;`custom_target_genelist` were passed. &#39;
                        &#39;`display_genes` will be ignored.&#39;)
        if display_genes:
            val = [&#39;variant&#39;, &#39;increasing&#39;, &#39;decreasing&#39;]
            if not differential:
                 val = [&#39;variant&#39;, &#39;distant&#39;, &#39;similar&#39;]
            if display_genes not in val:
                logger.error(&#39;The passed value for display_genes: `{}` is &#39;
                             &#39;invalid. Valid options when `differential` is&#39;
                             &#39; {} are {}.&#39;
                             .format(display_genes, differential, val))
                sys.exit(1)
        elif custom_target_genelist is None and specific_genes is None:
            logger.error(&#39;None of `display_genes`, `specific_genes` or &#39;
                         &#39;`custom_target_genelist` were passed&#39;)
            sys.exit(1)
        elif custom_target_genelist is not None and specific_genes is not None:
            specific_genes = None
            msg = (&#39;Both `specific_genes` and `custom_target_genelist` were&#39;
                   &#39; passed. `specific_genes` will be ignored.&#39;)
            logger.info(msg)
        config._update_consts(kwargs)
        
        # modify arguments for convneience 
        if show_genes_colorbar == True:
            if specific_genes:
                show_genes_colorbar = dict.fromkeys(specific_genes, 
                                                    config.colors[1])
            else:
                show_genes_colorbar = None

        # get a list of generally valid annotated genes
        genes = pd.DataFrame({&#39;name&#39;: util.annotate(self._mgs, self._species), 
                              &#39;ensg&#39;: self._mgs })
        if specific_genes is not None or custom_target_genelist is not None:
            # for gene input check if genes are detected in the target data
            if specific_genes is not None:
                inp_gl = pd.Index(specific_genes).drop_duplicates()
                val_gl = pd.Index(genes.name.values)
                isin = &#39;marker genes&#39;
            elif custom_target_genelist is not None:
                inp_gl = pd.Index(custom_target_genelist).drop_duplicates()
                val_gl_ensg = self._detec_genes.intersection(samples._detec_genes)
                isin = &#39;detected genes&#39;
                val_gl = pd.Index(util.annotate(val_gl_ensg, self._species))
            
            inv = [g for g in inp_gl if g not in val_gl]
            inp_gl = inp_gl.drop(inv) 
            if inv:
                logger.warning(&#39;{} ({}/{}) are not {} in any of the targets&#39;
                               &#39; or are not detected in the samples. These &#39;
                               &#39;genes will not be included.&#39;.format(inv,
                                len(inv), len(inv)+len(inp_gl), isin))
                if len(inv) == (len(inv)+len(inp_gl)):
                    sys.exit(1)
            # update passed list
            if specific_genes is not None:
                specific_genes = inp_gl
            elif custom_target_genelist is not None:
                genes = util.get_ensgs(inp_gl, self._species)
                # duplicated indicies are painful in pandas...
                if genes.name.duplicated().any():
                    val_gl = pd.Index(genes.ensg).intersection(val_gl_ensg)
                    genes = genes.reindex(genes.index[genes.ensg.isin(val_gl)])
                    if genes.name.tolist() != inp_gl.tolist():
                        try:
                            genes = genes.set_index(&#39;name&#39;).reindex(inp_gl)
                            genes.reset_index(inplace=True)
                            genes = genes.rename({&#39;index&#39;: &#39;name&#39;}, axis=1)
                        except Exception:
                            logger.warning(&#39;Input gene order could not be&#39;
                                           &#39;kept because of duplicate &#39;
                                           &#39;gene name issues.&#39;)
        logger.info(&#39;Arguments passed. Getting data now ...&#39;)
        return genes                   

    # get the specific similarity data and pick out the genes to display
    def get_data():
        # init a new target where all genes are marker genes of all targets
        if custom_target_genelist:
            nonlocal self
            expr = self._expr.reindex(genes.ensg).copy()
            args = {&#39;expression&#39;: expr}
            self = targets(name=&#39;custom genelist&#39;, ignore_down_mgs=True, 
                           log=False, **args)
        sim, ctrl_sim = self._get_similarity(samples, metric, &#39;gene_sim&#39;,
                                             differential=differential,
                                             drop_ctrl= not hide_distance_bar)

        # init mutable nested dict with target and markegene type keys
        data = dict((trg, dict((mgt, None) for mgt in self._mg_types))
                    for trg in self.names)
        # select genes, form the 3 data elements per-gene similarity (heatmap), 
        # ctrl_sim (distance_bar), target similarity (sumplot)
        def sel_genes(gene_sim, genes):
            mgt = gene_sim.columns[0][0]
            trg = gene_sim.columns[0][1]
            get_genes = pd.Index([])
            gene_sim.dropna(inplace=True)
            
            if display_genes:
                # sort similarities based on passed metric, slice to gene number
                if display_genes == &#39;variant&#39;:
                    idx = gene_sim.var(1).sort_values(ascending=False).index
                elif metric == &#39;euclid&#39;:
                    if display_genes in [&#39;increasing&#39;, &#39;distant&#39;]:
                        idx = gene_sim.max(1).sort_values(ascending=False).index
                    elif display_genes in [&#39;decreasing&#39;, &#39;similar&#39;]:
                        idx = gene_sim.min(1).sort_values().index       
                elif metric == &#39;intersect&#39;:
                    if display_genes.startswith(&#39;in&#39;) and mgt == &#39;down&#39; or \
                    display_genes.startswith(&#39;de&#39;) and mgt == &#39;up&#39;:
                        asc = True
                    elif display_genes.startswith(&#39;in&#39;) and mgt == &#39;up&#39; or \
                    display_genes.startswith(&#39;de&#39;) and mgt == &#39;down&#39;:
                        asc = False
                    idx = gene_sim.sum(1).sort_values(ascending=asc).index
                get_genes = idx[:gene_number]
                
            if specific_genes is not None:
                # check if passed genelist in target marker genes add them 
                # if not already in 
                inp_ensg = util.get_ensgs(specific_genes, self._species).ensg
                not_mg = filter(lambda ie: ie not in gene_sim.index, inp_ensg)
                inv = genes.set_index(&#39;ensg&#39;).reindex(not_mg).name
                if not inv.empty:
                    logger.info(&#39;{} not included: not marker genes of `&#39;
                                &#39;{}-{}`&#39;.format(inv.tolist(), mgt, trg))
                add = lambda ie: not (ie in get_genes or ie in inv)
                add_genes = pd.Index(filter(add, inp_ensg))
                if not add_genes.empty:
                    get_genes = get_genes.append(add_genes)
            elif custom_target_genelist:
                get_genes = genes.ensg
            
            if get_genes.empty:
                logger.error(&#39;No genes were picked for {}-{}. Check input.&#39;
                             .format(mgt, trg))
                sys.exit(1)
            # index per gene similarity to final gene list
            # per gene similarity for heatmap
            gs = gene_sim.reindex(get_genes)
            # target similarity for heatmap
            ts = gs.mean()

            # control similarity for distance bar
            if metric == &#39;euclid&#39; and not hide_distance_bar:
                cs = ctrl_sim.loc[get_genes, (mgt, trg, samples._ctrl)].to_frame().T
            else:
                cs = None
            data[trg][mgt] = (gs.T, cs, ts)
        
        # iterate target+marker gene type
        sim.groupby(axis=1, level=(0,1), sort=False).apply(sel_genes, genes)
        return data

    # get data limits across all targets and marker gene types to plot with 
    # one consistent heatmap range 
    def get_caps():
         # unpack nested dict into the 3 plot data elements       
        data_l = [e for dat in list(data.values())
                  for d in list(dat.values()) for e in d]
        # gene sim (heatmap), ctrl sim (distance bar) target sim (sum plot)
        gs, cs, ts = [data_l[get::3] for get in (0,1,2)]
        
         # get number of genes per plot
        n_genes = [ts.shape[1] for ts in gs]
        if self._down_mgs:
            n_genes = [max(gs[i].shape[1], gs[i+1].shape[1]) 
                       for i in range(0, len(gs), 2)]

         # get sum plot limits
        if sum_plot_range is not None:
            ts_lim = sum_plot_range
        else:
            ts_min = min([sim.min() for sim in ts])
            ts_max = max([sim.max() for sim in ts])
            ts_lim = [ts_min -abs(ts_min*.15), ts_max +abs(ts_max*.15)]
            # make sure 0 is included
            if differential or True:
                if ts_lim[0]&gt;=0 and ts_lim[1]&gt;=0:
                    ts_lim[ts_lim.index(min(ts_lim))] = 0
                elif ts_lim[0]&lt;=0 and ts_lim[1]&lt;=0:
                    ts_lim[ts_lim.index(max(ts_lim))] = 0
        
        # get per gene heatmap range (only required for euclid)
        if metric == &#39;euclid&#39;:
            if heatmap_range is not None:
                low_cap, up_cap = heatmap_range
            else:
                mini = [sim.min().sort_values()[int(sim.shape[1]*.05)] for sim in gs]
                maxi = [sim.max().sort_values()[int(sim.shape[1]*.95)] for sim in gs]
                up_cap = round(max((abs(min(mini)), abs(max(maxi)))), 1)
                low_cap = -up_cap if differential else 0
            
            # get distance bar range
            if not hide_distance_bar:
                if distance_bar_range is not None:
                    low_db_cap, up_db_cap = distance_bar_range
                else: 
                    up_db_cap = round(max([sim.iloc[0].sort_values()[int(sim.shape[1]*.95)]
                                        for sim in cs]), 1)
                    low_db_cap = 0

                # make sure heatmap and distance bar ranges align
                if not differential:
                    if heatmap_range is not None:
                        up_db_cap = up_cap
                        low_db_cap = low_cap
                    else:
                        up_cap = up_db_cap = max((up_cap, up_db_cap))
                        low_cap = low_db_cap
            else:
                up_db_cap = low_db_cap = None
            return up_cap, low_cap, up_db_cap, low_db_cap, ts_lim, n_genes
        # for the intersect mertic, the values can only be -1, 0 and 1
        elif metric == &#39;intersect&#39;:
            return 1, -1, None, None, ts_lim, n_genes
    
    # built 2 lists with widths and heights in inches of every axes
    def get_plot_sizes():
        nplts = [4, 4]
        # default size of an exes is 0
        fig_widths = [.0001] *(nplts[1] +3)
        # based on parameters and config constants, set all sizes
        fig_widths[0] = samplelabels_space if samplelabels_space \
                        else config.HM_LEFT
        if show_samples_colorbar:
            fig_widths[1] = config.HM_Y_COLORBAR
        # heatmap width varies across plots, a nested list stores widths
        fig_widths[2] = [n_gs*config.HM_SQUARE_SIZE for n_gs in n_genes]
        if heatmap_width:
            fig_widths[2] = [heatmap_width*f_ws2 for f_ws2 in fig_widths[2]]
        if cluster_samples and show_samples_dendrogram:
            fig_widths[3] = config.HM_Y_DENDROGRAM
        if not hide_sum_plot:
            fig_widths[4] = config.G_HM_SUMPLOT_SIZE
        fig_widths[5] = config.HM_WSPACE * (nplts[1]-1)
        fig_widths[6] = config.HM_RIGHT

        fig_heights = [.0001] *(nplts[0] +3)
        fig_heights[0] = config.HM_TOP
        if cluster_genes and not hide_genes_dendrogram:
            fig_heights[1] = config.HM_X_DENDROGRAM
        if not hide_distance_bar:
            fig_heights[2] = config.HM_DISTANCE_BAR 
        fig_heights[3] = config.HM_SQUARE_SIZE *len(samples._names_noctrl) 
        if heatmap_height:
            fig_heights[3] *= heatmap_height
        if show_genes_colorbar:
            fig_heights[4] = config.HM_X_COLORBAR
        fig_heights[5] = config.HM_HSPACE * (nplts[0]-1)
        fig_heights[6] = genelabels_space if genelabels_space else \
                         config.HM_BOTTOM

        # duplicate height sizes and insert a spacer axis with size of top
        if self._down_mgs:
            nplts[0] = nplts[0] *2 +1
            hs = fig_heights
            ins = [config.G_HM_UPDOWN_SPACE_SIZE]
            fig_heights = hs[:-2] + ins + hs[1:-2] + hs[-2:]
            fig_heights[-2] = config.HM_HSPACE * (nplts[0]-1)
        return nplts, fig_widths, fig_heights

    # draw plot
    def do_plot(i):
        # get final width list for specific number of genes in plot
        this_fig_widths = fig_widths[:2] +[fig_widths[2][i]] +fig_widths[3:]
        width, height = sum(this_fig_widths), sum(fig_heights)
        fig, axes = util._init_figure(this_fig_widths, fig_heights, nplts, 
                                      (config.HM_WSPACE, config.HM_HSPACE))
        if self._down_mgs:
            [ax.set_visible(False) for ax in axes[4, :]]

        # set plot title
        if title and title not in (&#39;None&#39;, &#39;none&#39;, &#39;False&#39;, &#39;false&#39;, &#39;F&#39;, &#39;f&#39;):
            if title == True:
                this_t = util._make_title(differential, metric,
                                          samples.name, t_name, 
                                          postf=&#39;per gene &#39;)
                if display_genes:
                    this_t += &#39; - most similarity {} genes&#39;.format(display_genes) 
                elif specific_genes is not None:
                    this_t += &#39; - list of specific marker genes&#39;
                elif custom_target_genelist is not None:
                    this_t += &#39; - custom list of genes&#39;
                
            elif title and isinstance(title, (list, tuple)):
                this_t = title[i]
            else:
                this_t = title
            if not pivot:
                fig.suptitle(this_t, y=1- (config.HM_TOP/height)*.7,
                             fontsize=config.FONTS)
            else:
                row = 2 if not self._down_mgs else 7
                axes[row, 0].set_ylabel(this_t, labelpad=10)
            
        # iterate over up and down plot-halfs
        for mgt, r in zip(self._mg_types, (0, 5)):
            sim, ctrl_sim, sim_trg = dat[mgt]

            # cluster genes/ samples and draw dendrograms
            if cluster_genes:
                at = axes[r, 1] if not hide_genes_dendrogram else axes[r, 0]
                order = util._heatmap_cluster(sim, &#39;top&#39;, at, &#39;columns&#39;)
                sim, ctrl_sim = util._align_indices([sim, ctrl_sim], order)
            if cluster_samples:
                at = axes[2+r, 2] if show_samples_dendrogram else axes[r, 0]
                order = util._heatmap_cluster(sim, &#39;right&#39;, at, &#39;rows&#39;)
                sim, sim_trg = util._align_indices([sim, sim_trg], order, 0)
            axes[r, 0].set_visible(False)

            # draw the distance bar 
            if not hide_distance_bar and metric == &#39;euclid&#39;:
                # set order to order of sorted values in distance bar (ctrl)
                if reorder_to_distance_bar:
                    order = ctrl_sim.iloc[0].sort_values().index
                    sim, ctrl_sim = util._align_indices([sim, ctrl_sim], order)
                    
                bar_args = {&#39;vmin&#39;: low_db_cap, &#39;vmax&#39;: up_db_cap,
                            &#39;cmap&#39;: &#39;afmhot&#39;}
                cb_lbl = config.EUCLID_ABS
                # only draw colorbar legend if not absolute
                if not hide_colorbar_legend and differential and mgt==&#39;up&#39;:
                    draw_cb = True
                else:
                    draw_cb = False
                # label of the distance bar on the left
                ctrl_lbl = samples._ctrl if not hide_samplelabels else &#39;&#39;
                util._plot_distance_bar(axes[1+r, :2], ctrl_sim, 
                                              ctrl_lbl, bar_args, draw_cb, 
                                              cb_lbl, fig, pivot, width, 
                                              height)

            # setup heatmap x axis, including the colorbar
            xlbl = genes.set_index(&#39;ensg&#39;).reindex(sim.columns).name.values
            if show_genes_colorbar:
                default = show_genes_colorbar.get(&#39;default&#39;, &#39;w&#39;) 
                cols = [show_genes_colorbar.get(g, default) for g in xlbl]
                cols = [c if is_color_like(c) else default for c in cols]
            else:
                cols = None
            util._setup_heatmap_xy(&#39;x&#39;, axes[3+r, 1], xlbl, pivot,
                                  hide_genelabels, genelabels_size, cols) 

            # setup heatmap y axis, including the colorbar
            ylbl = sim.index.unique(2)[::-1]
            cols = samples.get_colors(ylbl) if show_samples_colorbar else \
                   None
            util._setup_heatmap_xy(&#39;y&#39;, axes[2+r, 0], ylbl, pivot, 
                                  hide_samplelabels, samplelabels_size, cols)
            if self._down_mgs:
                tit = &#39;{} marker genes&#39;.format(mgt)
                pad = 13 if not hide_distance_bar else 4
                loc = &#39;right&#39; if not pivot else &#39;left&#39;
                axes[2+r, 0].set_title(tit, loc=loc, fontweight=&#39;bold&#39;, 
                                       fontsize=config.FONTS, pad=pad)
            
            # draw summary plot on the right
            if not hide_sum_plot:
                # general setup
                ax = axes[2+r, 3]
                ax.tick_params(labelbottom=True, bottom=True)
                if pivot:
                    ax.tick_params(labelrotation=90)
                     
                axes[3+r, 3].set_visible(False)
                axes[1+r, 3].set_visible(False)
                ax.set_axisbelow(True)
                ax.xaxis.grid(alpha=0.8, linestyle=&#39;dashed&#39;)

                # setup y axes
                nsmps = sim_trg.shape[0]
                ax.set_ylim(-.1, nsmps+.1)
                yts = np.arange(nsmps-.5, -.5, -1)
                ax.set_yticks(yts)

                # setup x axes
                ax.set_xlim(ts_lim)
                if metric == &#39;euclid&#39; and differential:
                    lbl = config.EUCLID_DIFF
                elif metric == &#39;euclid&#39; and not differential:
                    lbl = config.EUCLID_ABS
                    if not hide_distance_bar:
                        base = ctrl_sim.mean(1)
                        ax.vlines(base, 0, nsmps)
                        lbl += &#39;\n(line = base)&#39;
                elif metric == &#39;intersect&#39;:
                    lbl = config.INTERSECT
                if not pivot:
                    if (mgt==&#39;up&#39; and not self._down_mgs) or \
                    (mgt==&#39;down&#39; and self._down_mgs):
                        ax.set_xlabel(lbl)
                else:
                    ax.get_yaxis().set_label_position(&#39;right&#39;)
                    ax.set_ylabel(lbl, rotation=90, labelpad=5)
                    
                # if metric == &#39;euclid&#39;:
                blue = config.colors[18] 
                red = config.colors[14]
                cols = [red if v &gt;0 else blue for v in sim_trg.values]
                ax.barh(y=yts, width=sim_trg, color=cols)

            # draw heatmap
            ax = axes[2+r, 1]
            ax.set_yticks(np.arange(0, sim.shape[0]))
            ax.set_xticks(np.arange(0, sim.shape[1]))

            hm_args = {&#39;vmin&#39;: low_cap, &#39;vmax&#39;: up_cap}
            if metric == &#39;euclid&#39; and differential:
                    hm_args.update({&#39;cmap&#39;: &#39;RdBu_r&#39;})
                    cb_lbl = config.EUCLID_DIFF
            if metric == &#39;euclid&#39; and not differential:
                    hm_args.update({&#39;cmap&#39;: &#39;afmhot&#39;})
                    cb_lbl = config.EUCLID_ABS
            elif metric == &#39;intersect&#39;:
                    hm_args.update({&#39;cmap&#39;: config.RdBu_bin})
                    cb_lbl = config.INTERSECT_GENES
            im = ax.imshow(sim.values, aspect=&#39;auto&#39;, **hm_args)

            # setup heatmap colorbar legend and draw
            if mgt == &#39;up&#39; and not hide_colorbar_legend:    
                # add a new axis for the colorbar
                at = (config.CB_LEFT/width, 1- config.CB_TOP/height, 
                      config.CB_WIDTH/width, config.CB_HEIGHT/height)
                cax = fig.add_axes(at)
                cb = ax.figure.colorbar(im, cax=cax, orientation=&#39;horizontal&#39;) 
                cb.ax.set_xlabel(cb_lbl)
                cb.ax.get_xaxis().set_label_position(&#39;top&#39;)
                bar_ticks = [hm_args[&#39;vmin&#39;], hm_args[&#39;vmax&#39;]]
                cb.set_ticks(bar_ticks)                
                if metric == &#39;intersect&#39;:
                    bar_ticks = (&#39;mismatch&#39;, &#39;match&#39;)
                cb.ax.set_xticklabels(bar_ticks)
                if pivot:
                    cb.ax.tick_params(labelrotation=90)
            dat[mgt] = sim, ctrl_sim, sim_trg
        return fig, axes, dat
        
    spacer.info(&#39;\n\n&#39; + log_plot)
    logger.info(&#39;Plot: {} &amp; {}&#39;.format(self.name, samples.name))
    genes = _check_args()
    data = get_data()
    up_cap, low_cap, up_db_cap, low_db_cap, ts_lim, n_genes = get_caps()

    nplts, fig_widths, fig_heights = get_plot_sizes()
    spacer.info(&#39;&#39;)
    logger.info(&#39;Drawing...&#39;)
    if filename:
        filename, pp = util._open_file(filename)
        ftype = filename[-4:]
    ret = {}
    for i, (t_name, dat) in enumerate(data.items()):
        fig, axes, dat = do_plot(i)
        spacer.info(&#39;{}/{} --- {}&#39;.format(i+1, len(data), t_name))
        if plt_show:
            plt.show()
        ret.update({t_name: (fig, axes, dat)})
        if filename:
            this_png_fn = &#39;{}_{}{}&#39;.format(filename[:-4], t_name, ftype)
            util._save_file(fig, filename=this_png_fn, pp=pp)
    if filename:
        if pp:
            pp.close()
        logger.info(&#39;Plots saved at {}/{}\n\n&#39;
                    .format(os.path.abspath(os.curdir), filename))
    return ret </code></pre>
</details>
</dd>
<dt id="main.targets.targets.plot_detec_mgs_prop"><code class="name flex">
<span>def <span class="ident">plot_detec_mgs_prop</span></span>(<span>self, samples, plt_show=False, filename=None, specific_target_labels=None, log=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Show the proportion of detected marker genes in logs and a histogram.</p>
<p>Useful for adjusting the DROP_TARGET_DETEC_THR value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>samples</code></strong> :&ensp;<code>samples</code></dt>
<dd>The samples instance to check the detection
rate for.</dd>
<dt><strong><code>plt_show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Directly the histogram in a new
window. Defaults to False.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filename to save the generated
histogram. Defaults to detec_mgs_prop. + config.SAVE_FORMAT.
None results in no file being saved.</dd>
<dt><strong><code>specific_target_labels</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>define a specific set
of target labels to display. Defaults to None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>det</code></strong></dt>
<dd>A DataFrame with detection values used for logging and
plotting</dd>
</dl>
<h2 id="note">Note</h2>
<p>When the proportion of detection is at 0 for all targetss, an
error is raised.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_detec_mgs_prop(self, samples, plt_show=False, 
                        filename=None, specific_target_labels=None, log=True):
    &#34;&#34;&#34;Show the proportion of detected marker genes in logs and a histogram.

        Useful for adjusting the DROP_TARGET_DETEC_THR value.

        Args:
            samples (samples): The samples instance to check the detection 
                rate for.
            plt_show (bool, optional): Directly the histogram in a new
                window. Defaults to False.
            filename (str, optional): Filename to save the generated 
                histogram. Defaults to detec_mgs_prop. + config.SAVE_FORMAT.
                None results in no file being saved.
            specific_target_labels (list, optional): define a specific set 
                of target labels to display. Defaults to None
        Returns:
            det: A DataFrame with detection values used for logging and 
                plotting
        Note:
            When the proportion of detection is at 0 for all targetss, an 
            error is raised.
    &#34;&#34;&#34;
    # get proportion of detected marker genes
    if self._has_diff:
        trg_d = self._diff
    elif self._has_expr:
        cols = pd.MultiIndex.from_product((self._mg_types, self.names))
        trg_d = pd.DataFrame(True, self._expr.index, cols)
    smp_from = samples._expr if samples._has_expr else samples._diff
    smp_d = smp_from.reindex(self._mgs).notna().iloc(1)[0]
    det = trg_d.reindex(self._mgs).apply(lambda trg: trg &amp; smp_d).sum()
    n_mgs = trg_d.sum()
    order = (det/n_mgs).sort_values().index

    # log proportion of detected marker genes
    det = pd.DataFrame({&#39;n marker genes&#39;: n_mgs.reindex(order), 
                        &#39;detected in samples&#39;: det.reindex(order).values, 
                        &#39;proportion&#39;: (det/n_mgs).reindex(order).values})
    n_trgs = 10 if not len(order) &lt;20 else int(len(order)/2)
    edges = order.droplevel(0)[:n_trgs].append(order.droplevel(0)[-n_trgs:])
    df_edges = det.loc[(slice(None), edges), :].to_string()
    if log:
        spacer.info(&#39;&#39;)
        logger.info(&#39;Detection of targets ({}) marker genes in samples data &#39;
                    &#39;({}): \n{}\nShown are the {} edge proportion values.&#39;
                    .format(self.name, samples.name, df_edges, len(edges)))
    if (det[&#39;detected in samples&#39;] == 0).all():
        trg_genes = &#39;, &#39;.join(self._detec_genes[:3])
        smp_genes = &#39;, &#39;.join(samples._expr.index[:3]) if samples._has_expr \
                    else &#39;, &#39;.join(samples._diff.index[:3])
        msg = (&#39;None of the targets marker genes were detected in the &#39;
               &#39;samples. This is likely due to non-matching indeces from a &#39;
               &#39;species-mismatch. Targets gene index: {} ... Samples gene &#39;
               &#39;index: {}. Check the input files.&#39;
               .format(trg_genes, smp_genes))
        logger.error(msg)
        sys.exit(1)
    # draw the plot if filename is passed, otherwise only log and return df
    if filename or plt_show:
        if filename:
            filename, pp = util._open_file(filename)
        fig, ax = plt.subplots()
        ax.bar(np.arange(len(order)), det.proportion, edgecolor=&#39;k&#39;,
               width=1, color=self.get_colors(order.get_level_values(1)))
        ax.hlines(config.DROP_TARGET_DETEC_THR, 0, len(self))
        ax.yaxis.grid(alpha=0.8, linestyle=&#39;dashed&#39;)
        ax.set_xlabel(self.name+&#39; (targets)&#39;)
        if specific_target_labels:
            xlbl = [lbl if lbl in specific_target_labels else &#39;&#39; 
                    for lbl in order]
            ax.set_xticks(np.arange(len(xlbl)))
            ax.set_xticklabels(xlbl, rotation=45, ha=&#39;right&#39;, 
                            rotation_mode=&#39;anchor&#39;)
        ax.set_ylabel(&#39;Proportion of detected marker genes in samples&#39;)
        tit = (&#39;Proportion of detected {} marker genes in {}\nline = drop &#39;
               &#39;threshold&#39;).format(self.name, samples.name)
        ax.set_title(tit, fontsize=6)
        if plt_show:
            plt.show()
        if filename:
            util._save_file(fig, filename, pp, close_pp=True)
            logger.info(&#39;Plot saved at {}\n&#39;
                        .format(os.path.abspath(filename)))
        else:
            plt.close()
    return det</code></pre>
</details>
</dd>
<dt id="main.targets.targets.ranked_similarity_barplot"><code class="name flex">
<span>def <span class="ident">ranked_similarity_barplot</span></span>(<span>self, samples, metric=None, differential=True, display_markergenes='mean', n_targets=16, display_negative=False, rank_samples=False, pivot=False, xlim_range=None, targetlabels_space=None, targetlabels_size=None, colored_bars=False, spines=False, title=True, hide_targetlabels=False, hide_colorbar=False, hide_base_lines=False, filename='ranked_similarity_bp', plt_show=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt>Plot the ranked similarity of the samples with the targets in a</dt>
<dt><strong><code>barplot</code></strong></dt>
<dd>Sort the similarity values of the samples and targets to identify
the dominating effects in the samples. Two different metrics can be
picked to assess similarity: 'euclid' for expression inputs or
'intersect' for comparison based on diff. genes/ marker genes.
Differential and absolute similarity values are available
options for investagting the change in similarity.</dd>
</dl>
<h2 id="args">Args</h2>
<dl>
<dt>=================== Plot data options ===================</dt>
<dt><strong><code>samples</code></strong> :&ensp;<code>samples</code></dt>
<dd>the data to rank similariity for.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the similarity metric to use. Valid
options are 'euclid', 'intersect', 'cosine', 'pearson'. Defaults
to None.'euclid' shows the mean euclidean distance towards the
target marker genes expression levels and requires <code>expression</code>
input for samples and targets. 'intersect' will show the overlap
between diff. sample genes and target marker genes requiring
gene list input. 'cosine' will compute the cosine similarity,
'pearson' the Pearson correlation coefficient. More details in
publication. When None, set to 'cosine' when expression input
was passed, or 'intersect' when gene list data was passed.</dd>
<dt><strong><code>differential</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>plot the differential (change in)
similarity from the untreated-,/ base-sample, or. the control
to other samples. Defaults to True. Requires a control to be
passed for the expression-based metrics. Cannot be False for
'intersect'-metric.</dd>
<dt><strong><code>display_markergenes</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>specify the group of
marker genes to display similarity for. Defaults to 'mean'.
Valid options are 'mean', 'up', 'down'. Relevent when targets
are initiated with down-marker genes.</dd>
<dt><strong><code>n_targets</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the number of targets to display in each
plot. Defaults to 16. </dd>
<dt><strong><code>display_negative</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>display the most negative values
on the bottom half of the bar plot. Defaults to False. </dd>
<dt>=================== data ordering options ===================</dt>
<dt><strong><code>rank_samples</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Rank the samples based on their most
positive value and generate the barplots in the same order.
Defaults to False. When False, use the default samples order.</dd>
<dt>=================== general visual options ===================</dt>
<dt><strong><code>pivot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>pivot the barplot by 90 degrees.
Defaults to False. Useful for fitting the barplot on a canvas. </dd>
<dt><strong><code>xlim_range</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Define the lower- and upper
x-limits for the barplot. Defaults to None. The list is
interpreted as, [lower_limit, upper_limit]. When None, the
x-limits are defined by adding 15% to the minimum and maximum
values. </dd>
<dt><strong><code>targetlabels_space</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>define the size in inches
to reserve for target labels, here, the white space on the
left. Defaults to None. When None, refer to the value set in
config.BP_LEFT.</dd>
<dt><strong><code>targetlabels_size</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>multiplier for adjusting
target label size. Defaults to None. Useful for very high or low
number of targets.</dd>
<dt><strong><code>colored_bars</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>colorize negative values in blue,
positive ones in red. Defaults to False.</dd>
<dt><strong><code>spines</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>in addition to the bottom and left spines,
plot the top and right ones. Defaults to False.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>bool</code>, <code>str</code>, <code>list</code> optional</dt>
<dd>the plot title to set. Defaults to
True. For True, infer the title based on plot data inputs and
targets/ samples name attribute. Text input will be set as
the general title, False hides the title. A list of str will be
set according to the list of plots.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>modify the constants defined in config. This is used as an
advanced adjustment of plot element sizes and the minimum
required marker genes detection proportion. The barplots may be
adjusted by the following paramters: DROP_TARGET_DETEC_THR,
BP_LEFT, BP_TOP, BP_RIGHT, BP_BOTTOM, BP_Y_COLORBAR,
BP_BARSPACE, BP_BARWIDTH_SIZE.</dd>
<dt>=================== hide/show plot elements ===================</dt>
<dt><strong><code>hide_targetlabels</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the target labels
at the left. Defaults to False.</dd>
<dt><strong><code>hide_colorbar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the targets colorbar on
the left of the barplot. Defaults to False. </dd>
<dt><strong><code>hide_base_lines</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not show the lines marking
the absolute simialrity of the control, i.e. the base line. </dd>
<dt>=================== others ===================</dt>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the filename for saving the figure.
Defaults to 'ranked_similarity_bp.png'. Supported filename
endings are .png and .pdf. If filename does not end with
these, the filetype is retrieved from conifg.SAVE_FORMAT.
If None, the plot is not saved.</dd>
<dt><strong><code>plt_show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>directly show each created plot in a new
window. Defaults to False.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ranked_similarity_barplot(self,
                              # plot data
                              samples,
                              metric = None, 
                              differential = True,
                              display_markergenes = &#39;mean&#39;,
                              n_targets = 16,
                              display_negative = False,
                              # data ordering
                              rank_samples = False,
                              # general settings
                              pivot = False,
                              xlim_range = None,
                              targetlabels_space = None,
                              targetlabels_size = None,
                              colored_bars = False,
                              spines = False,
                              title = True,
                              # show/ hide elements
                              hide_targetlabels = False,
                              hide_colorbar = False,
                              hide_base_lines = False,
                              # others
                              filename = &#39;ranked_similarity_bp&#39;,
                              plt_show = False,
                              **kwargs):
    &#34;&#34;&#34;Plot the ranked similarity of the samples with the targets in a 
    barplot

        Sort the similarity values of the samples and targets to identify
        the dominating effects in the samples. Two different metrics can be 
        picked to assess similarity: &#39;euclid&#39; for expression inputs or 
        &#39;intersect&#39; for comparison based on diff. genes/ marker genes.
        Differential and absolute similarity values are available 
        options for investagting the change in similarity.

    Args:
        =================== Plot data options ===================
        samples (samples): the data to rank similariity for.
        metric (str, optional): the similarity metric to use. Valid 
            options are &#39;euclid&#39;, &#39;intersect&#39;, &#39;cosine&#39;, &#39;pearson&#39;. Defaults 
            to None.&#39;euclid&#39; shows the mean euclidean distance towards the 
            target marker genes expression levels and requires `expression` 
            input for samples and targets. &#39;intersect&#39; will show the overlap 
            between diff. sample genes and target marker genes requiring 
            gene list input. &#39;cosine&#39; will compute the cosine similarity, 
            &#39;pearson&#39; the Pearson correlation coefficient. More details in
            publication. When None, set to &#39;cosine&#39; when expression input 
            was passed, or &#39;intersect&#39; when gene list data was passed.
        differential (bool, optional): plot the differential (change in)
            similarity from the untreated-,/ base-sample, or. the control 
            to other samples. Defaults to True. Requires a control to be 
            passed for the expression-based metrics. Cannot be False for 
            &#39;intersect&#39;-metric.
        display_markergenes (str, optional): specify the group of 
            marker genes to display similarity for. Defaults to &#39;mean&#39;. 
            Valid options are &#39;mean&#39;, &#39;up&#39;, &#39;down&#39;. Relevent when targets 
            are initiated with down-marker genes.
        n_targets (int, optional): the number of targets to display in each
            plot. Defaults to 16. 
        display_negative (bool, optional): display the most negative values 
            on the bottom half of the bar plot. Defaults to False. 

        =================== data ordering options ===================
        rank_samples (bool, optional): Rank the samples based on their most 
            positive value and generate the barplots in the same order. 
            Defaults to False. When False, use the default samples order.
        
        =================== general visual options ===================
        pivot (bool, optional): pivot the barplot by 90 degrees. 
            Defaults to False. Useful for fitting the barplot on a canvas. 
        xlim_range (list, optional): Define the lower- and upper 
            x-limits for the barplot. Defaults to None. The list is 
            interpreted as, [lower_limit, upper_limit]. When None, the 
            x-limits are defined by adding 15% to the minimum and maximum
            values. 
        targetlabels_space (float, optional): define the size in inches
            to reserve for target labels, here, the white space on the
            left. Defaults to None. When None, refer to the value set in 
            config.BP_LEFT.
        targetlabels_size (float, optional): multiplier for adjusting 
            target label size. Defaults to None. Useful for very high or low 
            number of targets.
        colored_bars (bool, optional): colorize negative values in blue, 
            positive ones in red. Defaults to False.
        spines (bool, optional): in addition to the bottom and left spines,
            plot the top and right ones. Defaults to False.
        title (bool, str, list optional): the plot title to set. Defaults to 
            True. For True, infer the title based on plot data inputs and 
            targets/ samples name attribute. Text input will be set as 
            the general title, False hides the title. A list of str will be
            set according to the list of plots.
        kwargs: modify the constants defined in config. This is used as an 
            advanced adjustment of plot element sizes and the minimum 
            required marker genes detection proportion. The barplots may be
            adjusted by the following paramters: DROP_TARGET_DETEC_THR,
            BP_LEFT, BP_TOP, BP_RIGHT, BP_BOTTOM, BP_Y_COLORBAR, 
            BP_BARSPACE, BP_BARWIDTH_SIZE.

        =================== hide/show plot elements ===================
        hide_targetlabels (bool, optional): Do not plot the target labels 
            at the left. Defaults to False.
        hide_colorbar (bool, optional): Do not plot the targets colorbar on 
            the left of the barplot. Defaults to False. 
        hide_base_lines (bool, optional): Do not show the lines marking 
            the absolute simialrity of the control, i.e. the base line. 
        
        =================== others ===================
        filename (str, optional): the filename for saving the figure.
            Defaults to &#39;ranked_similarity_bp.png&#39;. Supported filename 
            endings are .png and .pdf. If filename does not end with 
            these, the filetype is retrieved from conifg.SAVE_FORMAT.
            If None, the plot is not saved.
        plt_show (bool, optional): directly show each created plot in a new
            window. Defaults to False.
        
    &#34;&#34;&#34;
    # check user input for errors and incompatibilities around `metric` arg
    def _check_args():
        nonlocal metric
        nonlocal differential
        nonlocal n_targets
        nonlocal display_markergenes

        # check general basic input requirements
        r = util._check_args(self, samples, metric, differential,  
                             display_markergenes=display_markergenes)
        metric, differential, _, _, _, _, display_markergenes = r
        if not n_targets or n_targets &gt; len(self):
            n_targets = len(self)
            logger.warning(&#39;The number of targets `n_targets` was None or &#39;
                           &#39;greater the length of the targets. Set to all &#39;
                           &#39;target elements ({}).&#39;.format(len(self)))
        config._update_consts(kwargs)            
        logger.info(&#39;Arguments passed. Getting data now ...&#39;)

    # get the target similarity data for plotting, pick the targets
    def get_data():
        sim, ctrl_sim = self._get_similarity(samples, metric, 
                                             differential=differential,
                                             drop_ctrl=differential)
        sim = sim.xs(display_markergenes, 1, 0)
        if rank_samples:
            if differential:
                order = sim.max(1).sort_values(ascending=False).index
            else:
                order = sim.min(1).sort_values().index
            sim = sim.reindex(order)
        
        # slice that selects the targets in the ranking
        drop = slice(int(n_targets/2), -int(n_targets/2)) if display_negative \
               else slice(-1, n_targets-1, -1)
        
        asc = True if metric == &#39;euclid&#39; and not differential else False
        data = dict.fromkeys(sim.index, None)
        def sel_trgs(smp_row):                
            trgs = smp_row.iloc[0].sort_values(ascending=asc)
            data[trgs.name] = trgs.drop(trgs.index[drop])
        sim.groupby(level=0).apply(sel_trgs)
        return data, ctrl_sim
    
    # get plot global limits
    def get_caps():
        if xlim_range is not None:
            return xlim_range
        else:
            maxi = max([trg_vals.max() for trg_vals in list(data.values())])
            mini = min([trg_vals.min() for trg_vals in list(data.values())])
            ext = max([abs(maxi), abs(mini)]) *.15
            lims = [mini -ext, maxi +ext]
            if lims[0]&gt;=0 and lims[1]&gt;=0:
                lims[lims.index(min(lims))] = 0
            elif lims[0]&lt;=0 and lims[1]&lt;=0:
                lims[lims.index(max(lims))] = 0
            return lims

    # built 2 lists with widths and heights in inches of every axes
    def get_plot_sizes():
        fig_widths = [.0001] *5
        fig_widths[0] = targetlabels_space if targetlabels_space else \
                        config.BP_LEFT   
        if not hide_colorbar:
            fig_widths[1] = config.BP_Y_COLORBAR
        fig_widths[2] = config.BP_BARSPACE
        fig_widths[3] = .04
        fig_widths[4] = config.BP_RIGHT
        
        fig_heights = [.0001] *4
        fig_heights[0] = config.BP_TOP
        fig_heights[1] = config.BP_BARWIDTH_SIZE *n_targets
        fig_heights[2] = 0
        fig_heights[3] = config.BP_BOTTOM
        return fig_widths, fig_heights
    
    # draw plot
    def do_plot(i, dat):
        height, width = sum(fig_heights), sum(fig_widths)
        fig, axes = util._init_figure(fig_widths, fig_heights, (1, 2), 
                                      (.04,0))
        ax = axes[1]
        if spines:
            ax.spines[&#39;right&#39;].set_visible(True)
            ax.spines[&#39;top&#39;].set_visible(True)

        # set plot title
        if title and title not in (&#39;None&#39;, &#39;none&#39;, &#39;False&#39;, &#39;false&#39;, &#39;F&#39;, &#39;f&#39;):
            if title == True:
                this_t = util._make_title(differential, metric, s_name, 
                                          self.name, pref=&#39;ranked &#39;)
            elif title and isinstance(title, (list, tuple)):
                this_t = title[i]
            else:
                this_t = title
            if not pivot:
                fig.suptitle(this_t, y=1- (config.BP_TOP/height)*.6,
                             fontsize=config.FONTS)
            else:
                ax.get_yaxis().set_label_position(&#39;right&#39;)
                ax.set_ylabel(this_t, rotation=-90, labelpad=25)

        # setup y axis including the colorbar
        ax.spines[&#39;left&#39;].set_visible(True)
        n = dat.shape[0] if not display_negative else dat.shape[0] +1
        ylim = n, -1
        yts = np.arange(n)
        [(ax.set_ylim(ylim), ax.set_yticks(yts)) for ax in axes]
        ylbls = dat.index.tolist()
        if not hide_colorbar:
            cols = self.get_colors(ylbls)
            if display_negative:
                cols.insert(int(len(ylbls)/2), &#39;w&#39;)
            axes[0].bar(0, 1, color=cols, bottom=yts-.5)
        # if negative, insert a gab between the two groups 
        if display_negative:
            ylbls.insert(int(len(ylbls)/2), &#39;&#39;)
            dat = dat.append(pd.Series(0, [&#39;&#39;])).reindex(ylbls)
            # delta half-height/ width of split line between pos. &amp; neg. group
            d_hh = (.01/fig_heights[1]) /2
            d_wh = (.03/fig_widths[2])
            line_args = {&#39;xdata&#39;: (-d_wh, d_wh), &#39;transform&#39;: ax.transAxes, 
                         &#39;clip_on&#39;: False, &#39;color&#39;: &#39;k&#39;}
            ax.add_line(Line2D(ydata=(.5-d_hh*1.25, .5-d_hh*.25), **line_args))
            ax.add_line(Line2D(ydata=(.5+d_hh*.25, .5+d_hh*1.25), **line_args))
        if not hide_targetlabels:
            axes[0].tick_params(labelleft=True)
            fs = config.FONTS*targetlabels_size if targetlabels_size else \
                 config.FONTS
            if not pivot:
                axes[0].set_yticklabels(ylbls, fontsize=fs)
            else:
                axes[0].set_yticklabels(ylbls, rotation=-45, ha=&#39;right&#39;, 
                                        x=-.5, rotation_mode=&#39;anchor&#39;, 
                                        fontsize=fs)
        
        # setup x axis
        xlim = lims
        if not pivot:
            ax.spines[&#39;bottom&#39;].set_visible(True)
            ax.tick_params(bottom=True, labelbottom=True)
        else:
            ax.spines[&#39;top&#39;].set_visible(True)
            ax.tick_params(top=True, labeltop=True, labelrotation=-90)
            ax.xaxis.set_label_position(&#39;top&#39;)
        ax.set_xlim(xlim)
        ax.set_axisbelow(True)
        ax.xaxis.grid(alpha=0.8, linestyle=&#39;dashed&#39;)

        if metric == &#39;euclid&#39; and differential:
            xlbl = config.EUCLID_DIFF
        elif metric == &#39;euclid&#39; and not differential:
            xlbl = config.EUCLID_ABS
        elif metric == &#39;cosine&#39; and differential:
            xlbl = config.COSINE_DIFF
        elif metric == &#39;cosine&#39; and not differential:
            xlbl = config.COSINE_ABS
        elif metric == &#39;pearson&#39; and differential:
            xlbl = config.PEARSON_DIFF
        elif metric == &#39;pearson&#39; and not differential:
            xlbl = config.PEARSON_ABS
        elif metric == &#39;intersect&#39;:
            xlbl = config.INTERSECT

        # for absolute euclid sim., mark the untreated base if available
        if not differential and samples._ctrl and not hide_base_lines:
            xs = ctrl_sim.loc[samples._ctrl, display_markergenes]
            xs = xs.reindex(ylbls, axis=1)
            ax.vlines(xs, yts-.4, yts+.4, linewidth=.5)
            xlbl += &#39;\n(line = base)&#39;
        ax.set_xlabel(xlbl, labelpad=5)

        if not colored_bars:
            cols = config.colors[19]
        else:
            blue = config.colors[18] 
            red = config.colors[14]
            cols = [red if v &gt;0 else blue for v in dat.values]
            
        ax.barh(yts, dat, color=cols)
        return fig, axes

    spacer.info(&#39;\n\n&#39; + log_plot)
    logger.info(&#39;Plot: {} &amp; {}&#39;.format(self.name, samples.name))
    _check_args()
    data, ctrl_sim = get_data()
    lims = get_caps()

    fig_widths, fig_heights = get_plot_sizes()
    spacer.info(&#39;&#39;)
    logger.info(&#39;Drawing...&#39;)
    if filename:
        filename, pp = util._open_file(filename)
        ftype = filename[-4:]
    ret = {}
    for i, (s_name, dat) in enumerate(data.items()):
        fig, axes = do_plot(i, dat)
        spacer.info(&#39;{}/{} --- {}&#39;.format(i+1, len(data), s_name))
        if plt_show:
            plt.show()
        ret.update({s_name: (fig, axes, dat)})
        if filename:
            this_png_fn = &#39;{}_{}.{}&#39;.format(filename[:-4], s_name, ftype)
            util._save_file(fig, filename=this_png_fn, pp=pp)
    if filename:
        if pp:
            pp.close()
        logger.info(&#39;Plots saved at {}/{}\n\n&#39;
                    .format(os.path.abspath(os.curdir), filename))
    return ret </code></pre>
</details>
</dd>
<dt id="main.targets.targets.target_similarity_heatmap"><code class="name flex">
<span>def <span class="ident">target_similarity_heatmap</span></span>(<span>self, samples, metric=None, differential=True, display_markergenes='mean', cluster_targets=False, cluster_samples=False, reorder_to_distance_bar=False, pivot=False, heatmap_width=None, heatmap_height=None, heatmap_range=None, distance_bar_range=None, specific_target_labels=None, targetlabels_space=None, samplelabels_space=None, targetlabels_size=None, samplelabels_size=None, title=True, hide_colorbar_legend=False, hide_distance_bar=False, hide_targetlabels=False, hide_targets_dendrogram=False, hide_targets_colorbar=False, hide_samplelabels=False, show_samples_dendrogram=False, show_samples_colorbar=False, plt_show=False, filename='target_similarity_hm', **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the similarity of the samples with the targets in a heatmap.</p>
<p>This gives a compact insight on transcriptional similarity with the
targets. Four different metrics can be picked to assess similarity:
'euclid', 'cosine' and 'pearson' for expression inputs or 'intersect'
for comparison based on diff. genes/ marker genes. Differential and
absolute similarity values are available options for investigating the
change or state in similarity with the targets.</p>
<h2 id="args">Args</h2>
<dl>
<dt>=================== Plot data options ===================</dt>
<dt><strong><code>samples</code></strong> :&ensp;<code>samples</code></dt>
<dd>the data to rate similarity for.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the similarity metric to use. Valid
options are 'euclid', 'intersect', 'cosine', 'pearson'. Defaults
to None.'euclid' shows the mean euclidean distance towards the
target marker genes expression levels and requires <code>expression</code>
input for samples and targets. 'intersect' will show the overlap
between diff. sample genes and target marker genes requiring
gene list input. 'cosine' will compute the cosine similarity,
'pearson' the Pearson correlation coefficient. More details in
publication. When None, set to 'cosine' when expression input
was passed, or 'intersect' when gene list data was passed.</dd>
<dt><strong><code>differential</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>plot the differential (change in)
similarity from the untreated-,/ base-sample, or. the control
to other samples. Defaults to True. Requires a control to be
passed for the expression-based metrics. Cannot be False for
'intersect'-metric.</dd>
<dt><strong><code>display_markergenes</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>specify the group of
marker genes to display similarity for. Defaults to 'mean'.
Valid options are 'mean', 'up', 'down'. Relevent when targets
are initiated with down-marker genes.</dd>
<dt>=================== data ordering options ===================</dt>
<dt><strong><code>cluster_targets</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>cluster targets using the
euclidean distance. Defaults to False.</dd>
<dt><strong><code>cluster_samples</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>cluster samples using the
euclidean distance. Defaults to False.</dd>
<dt><strong><code>reorder_to_distance_bar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>reorder the targets
from lowest to highest base distance. Defaults to False.
Cannot be True when
'cluster_targets' is True aswell.
For details, check the 'hide_distance_bar' argument. </dd>
<dt>=================== general visual options ===================</dt>
<dt><strong><code>pivot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>pivot the heatmap by 90 degrees. Defaults to
False. Useful for fitting the heatmap on a canvas. </dd>
<dt><strong><code>heatmap_width</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>multiplier to stretch/ squeeze
the heatmap squares in x direction. Defaults to None.
Useful for very low or high number of targets. For pivot = True
this paramter controls the height. </dd>
<dt><strong><code>heatmap_height</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>multiplier to stretch/ squeeze
the heatmap squares in y direction. Defaults to None.
Useful for very low or high number of samples. For pivot = True
this paramter controls the width. </dd>
<dt><strong><code>distance_bar_range</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Define the range of values
that form the colormap for the distance bar. Defaults to
None. The list is interpreted as, [lower_limit, upper_limit].
When None, the edges are defined to cover all occuring values. </dd>
<dt><strong><code>specific_target_labels</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>define a specific set of
target labels to display. Defaults to None</dd>
<dt><strong><code>targetlabels_space</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>define the size in inches
to reserve for target labels, here, the white space on the
bottom. Defaults to None. When None, refer to the values set in
config.HM_BOTTOM.</dd>
<dt><strong><code>samplelabels_space</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>define the size in inches
to reserve for sample labels, here, the white space on the
left. Defaults to None. When None, refer to the value set in
config.HM_LEFT.</dd>
<dt><strong><code>targetlabels_size</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>multiplier for adjusting
target label size. Defaults to None. Useful for very high or low
number of targets.</dd>
<dt><strong><code>samplelabels_size</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>multiplier for adjusting
sample label size. Defaults to None. Useful for very high or low
number of samples.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>bool</code>, <code>str</code>, optional</dt>
<dd>the plot title to set. Defaults to
True. For True, infer the title based on plot data inputs and
targets/ samples name attribute. Text input will be set as
the general title, False hides the title.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>modify the constants defined in config. This is used as an
advanced adjustment of plot element sizes and the minimum
required marker genes detection proportion. This heatmap may be
adjusted by the following paramters: DROP_TARGET_DETEC_THR,
HM_LEFT, HM_TOP, HM_RIGHT, HM_BOTTOM, HM_WSPACE,
HM_HSPACE, HM_Y_COLORBAR, HM_X_COLORBAR, HM_DISTANCE_BAR,
HM_Y_DENDROGRAM, HM_X_DENDROGRAM, HM_SQUARE_SIZE, CB_LEFT,
CB_LEFT_SEC, CB_TOP, CB_WIDTH, CB_HEIGHT.</dd>
<dt>=================== hide/show plot elements ===================</dt>
<dt><strong><code>hide_colorbar_legend</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the colorbar
legend. Defaults to False. Applies for all colorbar_legends.</dd>
<dt><strong><code>hide_distance_bar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the distance
bar on top of the heatmap. Defaults to False. When True, the
control will appear in the main heatmap. For the expression-
based metrics, this bar visualizes the absolute similarity of
the control with the targets. For the 'intersect' metric, the
number of target marker genes is shown. Defaults to False.</dd>
<dt><strong><code>hide_targetlabels</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the target
labels at the bottom. Defaults to False.</dd>
<dt><strong><code>hide_targets_dendrogram</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the
targets dendrogram from clustering. Defaults to False.
Requires 'cluster_targets' to be True. </dd>
<dt><strong><code>hide_targets_colorbar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the targets
colorbar on the bottom of the heatmap. Defaults to False.
When colors are not set for the targets using the
set_colors() function, colors are set to white.</dd>
<dt><strong><code>hide_samplelabels</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do not plot the sample
labels at the left. Defaults to False.</dd>
<dt><strong><code>show_samples_dendrogram</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Plot the samples
dendrogram from clustering. Defaults to False. Requires
'cluster_samples' to be True.</dd>
<dt><strong><code>show_samples_colorbar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Plot the samples
colorbar on the left of the heatmap. Defaults to False.
When colors are not set for the targets using the
set_colors() function, colors are set to white. </dd>
<dt>=================== others ===================</dt>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the filename for saving the figure.
Defaults to 'target_similarity_hm.png'. Supported filename
endings are .png and .pdf. If filename does not end with
these, the filetype is retrieved from conifg.SAVE_FORMAT.
If None, the plot is not saved.</dd>
<dt><strong><code>plt_show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>directly show the created plot in a new
window. Defaults to False.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def target_similarity_heatmap(self, 
                              # plot data
                              samples, 
                              metric = None, 
                              differential = True,
                              display_markergenes = &#39;mean&#39;,
                              # data ordering
                              cluster_targets = False,
                              cluster_samples = False,
                              reorder_to_distance_bar = False,
                              # general settings
                              pivot = False,
                              heatmap_width = None,
                              heatmap_height = None,
                              heatmap_range = None,
                              distance_bar_range = None,
                              specific_target_labels = None,
                              targetlabels_space = None,
                              samplelabels_space = None,
                              targetlabels_size = None,
                              samplelabels_size = None,
                              title = True, 
                              # show/ hide elements 
                              hide_colorbar_legend = False,
                              hide_distance_bar = False,
                              hide_targetlabels = False,
                              hide_targets_dendrogram = False,
                              hide_targets_colorbar = False,
                              hide_samplelabels = False,
                              show_samples_dendrogram = False,
                              show_samples_colorbar = False,
                              # others
                              plt_show = False,
                              filename = &#39;target_similarity_hm&#39;,
                              **kwargs):
    &#34;&#34;&#34;Plot the similarity of the samples with the targets in a heatmap.
    
    This gives a compact insight on transcriptional similarity with the 
    targets. Four different metrics can be picked to assess similarity: 
    &#39;euclid&#39;, &#39;cosine&#39; and &#39;pearson&#39; for expression inputs or &#39;intersect&#39; 
    for comparison based on diff. genes/ marker genes. Differential and 
    absolute similarity values are available options for investigating the 
    change or state in similarity with the targets.

    Args:
        =================== Plot data options ===================
        samples (samples): the data to rate similarity for.
        metric (str, optional): the similarity metric to use. Valid 
            options are &#39;euclid&#39;, &#39;intersect&#39;, &#39;cosine&#39;, &#39;pearson&#39;. Defaults 
            to None.&#39;euclid&#39; shows the mean euclidean distance towards the 
            target marker genes expression levels and requires `expression` 
            input for samples and targets. &#39;intersect&#39; will show the overlap 
            between diff. sample genes and target marker genes requiring 
            gene list input. &#39;cosine&#39; will compute the cosine similarity, 
            &#39;pearson&#39; the Pearson correlation coefficient. More details in
            publication. When None, set to &#39;cosine&#39; when expression input 
            was passed, or &#39;intersect&#39; when gene list data was passed.
        differential (bool, optional): plot the differential (change in)
            similarity from the untreated-,/ base-sample, or. the control 
            to other samples. Defaults to True. Requires a control to be 
            passed for the expression-based metrics. Cannot be False for 
            &#39;intersect&#39;-metric.
        display_markergenes (str, optional): specify the group of 
            marker genes to display similarity for. Defaults to &#39;mean&#39;. 
            Valid options are &#39;mean&#39;, &#39;up&#39;, &#39;down&#39;. Relevent when targets 
            are initiated with down-marker genes.

        =================== data ordering options ===================
        cluster_targets (bool, optional): cluster targets using the 
            euclidean distance. Defaults to False.
        cluster_samples (bool, optional): cluster samples using the 
            euclidean distance. Defaults to False.
        reorder_to_distance_bar (bool, optional): reorder the targets
            from lowest to highest base distance. Defaults to False. 
            Cannot be True when  &#39;cluster_targets&#39; is True aswell.
            For details, check the &#39;hide_distance_bar&#39; argument. 

        =================== general visual options ===================
        pivot (bool, optional): pivot the heatmap by 90 degrees. Defaults to 
            False. Useful for fitting the heatmap on a canvas. 
        heatmap_width (float, optional): multiplier to stretch/ squeeze 
            the heatmap squares in x direction. Defaults to None. 
            Useful for very low or high number of targets. For pivot = True
            this paramter controls the height. 
        heatmap_height (float, optional): multiplier to stretch/ squeeze 
            the heatmap squares in y direction. Defaults to None. 
            Useful for very low or high number of samples. For pivot = True
            this paramter controls the width. 
        distance_bar_range (list, optional): Define the range of values
            that form the colormap for the distance bar. Defaults to
            None. The list is interpreted as, [lower_limit, upper_limit]. 
            When None, the edges are defined to cover all occuring values. 
            
        specific_target_labels (list, optional): define a specific set of
            target labels to display. Defaults to None
        targetlabels_space (float, optional): define the size in inches
            to reserve for target labels, here, the white space on the
            bottom. Defaults to None. When None, refer to the values set in 
            config.HM_BOTTOM.
        samplelabels_space (float, optional): define the size in inches
            to reserve for sample labels, here, the white space on the
            left. Defaults to None. When None, refer to the value set in 
            config.HM_LEFT.
        targetlabels_size (float, optional): multiplier for adjusting 
            target label size. Defaults to None. Useful for very high or low 
            number of targets.
        samplelabels_size (float, optional): multiplier for adjusting 
            sample label size. Defaults to None. Useful for very high or low 
            number of samples.
        title (bool, str, optional): the plot title to set. Defaults to 
            True. For True, infer the title based on plot data inputs and 
            targets/ samples name attribute. Text input will be set as 
            the general title, False hides the title.
        kwargs: modify the constants defined in config. This is used as an 
            advanced adjustment of plot element sizes and the minimum 
            required marker genes detection proportion. This heatmap may be
            adjusted by the following paramters: DROP_TARGET_DETEC_THR,
            HM_LEFT, HM_TOP, HM_RIGHT, HM_BOTTOM, HM_WSPACE, 
            HM_HSPACE, HM_Y_COLORBAR, HM_X_COLORBAR, HM_DISTANCE_BAR, 
            HM_Y_DENDROGRAM, HM_X_DENDROGRAM, HM_SQUARE_SIZE, CB_LEFT, 
            CB_LEFT_SEC, CB_TOP, CB_WIDTH, CB_HEIGHT.
        
        =================== hide/show plot elements ===================
        hide_colorbar_legend (bool, optional): Do not plot the colorbar 
            legend. Defaults to False. Applies for all colorbar_legends.
        hide_distance_bar (bool, optional): Do not plot the distance 
            bar on top of the heatmap. Defaults to False. When True, the 
            control will appear in the main heatmap. For the expression-
            based metrics, this bar visualizes the absolute similarity of 
            the control with the targets. For the &#39;intersect&#39; metric, the 
            number of target marker genes is shown. Defaults to False.
        hide_targetlabels (bool, optional): Do not plot the target 
            labels at the bottom. Defaults to False.
        hide_targets_dendrogram (bool, optional): Do not plot the 
            targets dendrogram from clustering. Defaults to False. 
            Requires &#39;cluster_targets&#39; to be True. 
        hide_targets_colorbar (bool, optional): Do not plot the targets
            colorbar on the bottom of the heatmap. Defaults to False. 
            When colors are not set for the targets using the 
            set_colors() function, colors are set to white.
        hide_samplelabels (bool, optional): Do not plot the sample 
            labels at the left. Defaults to False.
        show_samples_dendrogram (bool, optional): Plot the samples 
            dendrogram from clustering. Defaults to False. Requires 
            &#39;cluster_samples&#39; to be True.
        show_samples_colorbar (bool, optional): Plot the samples
            colorbar on the left of the heatmap. Defaults to False. 
            When colors are not set for the targets using the 
            set_colors() function, colors are set to white. 

        =================== others ===================
        filename (str, optional): the filename for saving the figure.
            Defaults to &#39;target_similarity_hm.png&#39;. Supported filename 
            endings are .png and .pdf. If filename does not end with 
            these, the filetype is retrieved from conifg.SAVE_FORMAT.
            If None, the plot is not saved.
        plt_show (bool, optional): directly show the created plot in a new
            window. Defaults to False.
    &#34;&#34;&#34;
    # check user input for errors and incompatibilities
    def _check_args():
        nonlocal metric
        nonlocal differential

        nonlocal cluster_targets
        nonlocal reorder_to_distance_bar
        nonlocal hide_distance_bar
        nonlocal display_markergenes
        nonlocal distance_bar_range

        # check general basic input requirements
        r = util._check_args(self, samples, metric, differential, 
                            hide_distance_bar, reorder_to_distance_bar,
                            distance_bar_range, cluster_targets, 
                            display_markergenes)
        metric, differential, hide_distance_bar, reorder_to_distance_bar, \
        distance_bar_range, cluster_targets, display_markergenes = r
            
        config._update_consts(kwargs)
        spacer.info(&#39;&#39;)
        logger.info(&#39;Arguments passed. Getting data now ...&#39;)

    # get the specific similarity data, plot the mean of up and down mgs
    def get_data():
        sim, ctrl_sim = self._get_similarity(samples, metric, 
                                             differential=differential,
                                             drop_ctrl= not hide_distance_bar)
        if ctrl_sim is None:
            ctrl_sim =  pd.DataFrame(0, [0], sim.columns)
        return [sim.xs(display_markergenes, 1, 0), 
                ctrl_sim.xs(display_markergenes, 1, 0)]

    # get plot lims
    def get_caps():
        # get min and max value in data, set to caps
        if heatmap_range is not None:
            low_cap, up_cap = heatmap_range
        else:
            mini = abs(data[0].min().min())
            maxi = abs(data[0].max().max())
            up_cap = round(max((mini, maxi)), 1)
            low_cap = -up_cap
        # for the distance bar, set lims to 0,max for euclid, intersect and 
        # to -1,1 for cosine, pearson
        if distance_bar_range is not None:
            low_db_cap, up_db_cap = distance_bar_range
        else: 
            if metric in [&#39;euclid&#39;, &#39;intersect&#39;]:
                up_db_cap = round(data[1].iloc[0].max(), 1)
                low_db_cap = 0
            elif metric == &#39;cosine&#39;:
                up_db_cap = 1
                low_db_cap = -1
            elif metric == &#39;pearson&#39;:
                up_db_cap = 1
                low_db_cap = round(data[1].iloc[0].min(), 1)
        # for absolute, both distance bar and main bar sacles must be equal
        if not differential:
            if heatmap_range is not None:
                up_db_cap = up_cap
                low_db_cap = low_cap
            elif metric == &#39;euclid&#39;:
                up_cap = up_db_cap = max((up_cap, up_db_cap))
                low_cap = low_db_cap
            elif metric in [&#39;cosine&#39;, &#39;pearson&#39;]:
                up_cap = up_db_cap
                low_cap = low_db_cap

        return low_cap, up_cap, low_db_cap, up_db_cap
    
    # built 2 lists with widths and heights in inches of every axes
    def get_plot_sizes():
        nplts = [4,3]
        fig_widths = [.0001] *(nplts[1] +3)
        fig_widths[0] = samplelabels_space if samplelabels_space else \
                        config.HM_LEFT

        if show_samples_colorbar:
            fig_widths[1] = config.HM_Y_COLORBAR
        fig_widths[2] = config.HM_SQUARE_SIZE * data[0].shape[1]
        if heatmap_width:
            fig_widths[2] *= heatmap_width
        if cluster_samples and show_samples_dendrogram:
            fig_widths[3] = config.HM_Y_DENDROGRAM
        fig_widths[4] = config.HM_WSPACE * (nplts[1]-1)
        fig_widths[5] = config.HM_RIGHT

        fig_heights = [.0001] *(nplts[0] +3)
        fig_heights[0] = config.HM_TOP
        if cluster_targets and not hide_targets_dendrogram:
            fig_heights[1] = config.HM_X_DENDROGRAM
        if not hide_distance_bar:
            fig_heights[2] = config.HM_DISTANCE_BAR
        fig_heights[3] = config.HM_SQUARE_SIZE * len(samples._names_noctrl)
        if heatmap_height:
            fig_heights[3] *= heatmap_height
        if not hide_targets_colorbar:
            fig_heights[4] = config.HM_X_COLORBAR
        fig_heights[5] = config.HM_HSPACE * (nplts[0]-1)
        fig_heights[6] = targetlabels_space if targetlabels_space else \
                         config.HM_BOTTOM

        return nplts, fig_widths, fig_heights

    # draw plot
    def do_plot():
        width, height = sum(fig_widths), sum(fig_heights)
        fig, axes = util._init_figure(fig_widths, fig_heights, nplts, 
                                   (config.HM_WSPACE, config.HM_HSPACE))
        sim, ctrl_sim = data

        # set plot title
        if title and title not in (&#39;None&#39;, &#39;none&#39;, &#39;False&#39;, &#39;false&#39;, &#39;F&#39;, &#39;f&#39;):
            if title and type(title) is not str:
                this_t = util._make_title(differential, metric, 
                                          samples.name, self.name)
            else:
                this_t = title
            if not pivot:
                fig.suptitle(this_t, y=1- (config.HM_TOP/height)*.7, 
                             fontsize=config.FONTS)
            else:
                axes[2, 0].set_ylabel(this_t, labelpad=10)

        # cluster targets/ samples and draw dendrograms
        if cluster_targets:
            at = axes[0, 1] if not hide_targets_dendrogram else axes[0, 0]
            order = util._heatmap_cluster(sim, &#39;top&#39;, at, &#39;columns&#39;)
            sim, ctrl_sim = util._align_indices([sim, ctrl_sim], order)
        if cluster_samples:
            at = axes[2, 2] if show_samples_dendrogram else axes[0, 0]
            order = util._heatmap_cluster(sim, &#39;right&#39;, at, &#39;rows&#39;)
            sim = sim.reindex(order)
        axes[0, 0].set_visible(False)
        
        # draw distance effect bar
        if not hide_distance_bar:
            # set order to order of sorted values in distance bar (ctrl)
            if reorder_to_distance_bar:
                order = ctrl_sim.iloc[0].sort_values().index
                sim, ctrl_sim = util._align_indices([sim, ctrl_sim], order)
            # only draw colorbar legend if not absolute
            draw_cb = False if hide_colorbar_legend or not differential else True
            # label of the distance bar on the left
            if metric != &#39;intersect&#39; and not hide_samplelabels:
                ctrl_lbl = samples._ctrl
            else:
                ctrl_lbl = &#39;&#39;
            # general metric depended labling
            bar_args = {&#39;cmap&#39;: &#39;afmhot_r&#39;, &#39;vmin&#39;: low_db_cap, &#39;vmax&#39;: up_db_cap}
            if metric == &#39;euclid&#39;:                    
                cb_lbl = &#39;Base &#39; + config.EUCLID_ABS
                bar_args.update({&#39;cmap&#39;: &#39;afmhot&#39;})
            elif metric == &#39;cosine&#39;:
                cb_lbl = &#39;Base &#39; + config.COSINE_ABS
            elif metric == &#39;pearson&#39;:
                cb_lbl = &#39;Base &#39; + config.PEARSON_ABS
            elif metric == &#39;intersect&#39;:
                cb_lbl = config.INTERSECT_DIST_BAR
                bar_args.update({&#39;cmap&#39;: &#39;afmhot&#39;})
            util._plot_distance_bar(axes[1, :2], ctrl_sim,
                                        ctrl_lbl, bar_args, draw_cb, 
                                        cb_lbl, fig, pivot, width, height)

        # setup heatmap x,y axis, including the colorbars
        cols = self.get_colors(sim.columns) if not hide_targets_colorbar \
               else None
        xlbl = sim.columns
        if specific_target_labels:
            xlbl = [lbl if lbl in specific_target_labels else &#39;&#39; for lbl in xlbl]
        util._setup_heatmap_xy(&#39;x&#39;, axes[3, 1], xlbl, pivot,
                              hide_targetlabels, targetlabels_size, cols)
               
        cols = samples.get_colors(sim.index[::-1]) if show_samples_colorbar \
               else None
        util._setup_heatmap_xy(&#39;y&#39;, axes[2, 0], sim.index[::-1], pivot, 
                               hide_samplelabels, samplelabels_size, cols)

        ax = axes[2, 1]
        ax.set_yticks(np.arange(0, sim.shape[0]))
        ax.set_xticks(np.arange(0, sim.shape[1]))
        hm_args = {&#39;vmin&#39;: low_cap, &#39;vmax&#39;: up_cap}
        hm_args[&#39;cmap&#39;] = &#39;RdBu_r&#39; if differential else &#39;afmhot_r&#39;
        if metric == &#39;euclid&#39; and differential:
            cb_lbl = config.EUCLID_DIFF
        elif metric == &#39;euclid&#39; and not differential:
            cb_lbl = config.EUCLID_ABS
            hm_args[&#39;cmap&#39;] = &#39;afmhot&#39;
        elif metric == &#39;cosine&#39; and differential:
            cb_lbl = config.COSINE_DIFF
        elif metric == &#39;cosine&#39; and not differential:
            cb_lbl = config.COSINE_ABS
        elif metric == &#39;pearson&#39; and differential:
            cb_lbl = config.PEARSON_DIFF
        elif metric == &#39;pearson&#39; and not differential:
            cb_lbl = config.PEARSON_ABS
        elif metric == &#39;intersect&#39;:
            cb_lbl = config.INTERSECT
        im = ax.imshow(sim.values, aspect=&#39;auto&#39;, **hm_args)
        
        # setup heatmap colorbar legend and draw
        if not hide_colorbar_legend:
            at = (config.CB_LEFT/width, 1- config.CB_TOP/height, 
                  config.CB_WIDTH/width, config.CB_HEIGHT/height)
            cax = fig.add_axes(at)
            cb = ax.figure.colorbar(im, cax=cax, orientation=&#39;horizontal&#39;) 
            
            bar_ticks = [hm_args[&#39;vmin&#39;], hm_args[&#39;vmax&#39;]]
            cb.set_ticks(bar_ticks)
            cb.ax.set_xticklabels(bar_ticks)
            if pivot:
                cb.ax.tick_params(labelrotation=90)
            cb.ax.set_xlabel(cb_lbl)
            cb.ax.get_xaxis().set_label_position(&#39;top&#39;)

        return fig, axes, (sim, ctrl_sim)

    spacer.info(&#39;\n\n&#39; + log_plot)
    logger.info(&#39;Plot: {} &amp; {}&#39;.format(self.name, samples.name))
    _check_args()
    data = get_data()
    low_cap, up_cap, low_db_cap, up_db_cap = get_caps()

    nplts, fig_widths, fig_heights = get_plot_sizes()
    spacer.info(&#39;&#39;)
    logger.info(&#39;Drawing...&#39;)
    if filename:
        filename, pp = util._open_file(filename)
    fig, axes, data = do_plot()
    if plt_show:
        plt.show()
    if filename:
        util._save_file(fig, filename=filename, pp=pp, close_pp=True)
        logger.info(&#39;Plot saved at {}/{}\n\n&#39;
                    .format(os.path.abspath(os.curdir), filename))
    else:
        plt.close(fig)
    return fig, axes, data</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="main" href="index.html">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="main.targets.targets" href="#main.targets.targets">targets</a></code></h4>
<ul class="">
<li><code><a title="main.targets.targets.gene_similarity_heatmap" href="#main.targets.targets.gene_similarity_heatmap">gene_similarity_heatmap</a></code></li>
<li><code><a title="main.targets.targets.plot_detec_mgs_prop" href="#main.targets.targets.plot_detec_mgs_prop">plot_detec_mgs_prop</a></code></li>
<li><code><a title="main.targets.targets.ranked_similarity_barplot" href="#main.targets.targets.ranked_similarity_barplot">ranked_similarity_barplot</a></code></li>
<li><code><a title="main.targets.targets.target_similarity_heatmap" href="#main.targets.targets.target_similarity_heatmap">target_similarity_heatmap</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>