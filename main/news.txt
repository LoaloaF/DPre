valid input files:
    folder with deseq2 results (+expression) -> from_diff() pass two tables
    folder with genelists -> from_gl() pass one table (possibly two for down)


DPre

fmt_deseq2_out(path, p_th=.05)                // write table from deseq2 output to read
    pass

fmt_genelist_files(path)            // write table from all gl files to read
    pass




// init1
def from_gl(obj_type, up, down=None, expr=None)          // read in genelist, up or down or both, return targets/ drivers obj.
    pass

// init2
def from_diff(obj_type, diff_lfcp, down=True, expr=None)      // read in differential dataframe, return targets/ drivers obj.
    pass




__differential

    def __init__()
        pd.Dataframe(type=bool) = diff              // differential genes (lbl (* 2 if up&dn))
        pd.DataFrame(type=float) = diff_lfcp = None // differential lfc and p (lbl * (lfc, p))
        pd.DataFrame(type=float) = expr = None      // raw expression data (lbl * (expr, sem, z))
        diff.columns = names                          // column names -> condidtions 
        bool up_dn_mgs = False                      // weather down was passed
        colors = default_colors()                   // for plots later

    def get(name)            // return a list of e if available: diff, diff_lfcp, expr
        pass

    def get_diffgl(name)              // return the diff genelist of one condition
        get(name)
        pass

    def default_colors()                // generate random colors
        pass

    set_names(names)                     // set new names
        self.names = names

    set_colors(colors)
        self.colors = colors            // set new colors


    '''=====PLOTS======'''
    def diff_gene_numbers(sort=False)                 // bar plot
        pass
        -> length(ensg keys) for each name (1d)

    def diff_gene_overlap()                             // venn diagramm (super fancy)
        pass
        -> overlap between each combination name * name /2 (2d)
 

    
    def map_expression(map_genes=self)                            // self provides the gl key, overlap with expr
        pass                                                                    // show_overlap 'single' or 'double'
        -> ensg keys for each name (2d, no matrix)

        always optional:
        additional down mgs graph

        most basic:
        targets/drivers genes, targets/drivers expression, 1 bp per element
         -> self mapping, normal mapping 
        
        +intersection:
        same as above, but 3 bp's per element, splitting markergenes
        Only insightfull if both expression sets are shown: 3 additional bps next to original ones
        -> most inforamtion rich graph. Perhaps overplotted though. 

        include option for threshhold to limit targets or drivers elements   

    def map_overlap_expression(double=False)

drivers(__differential)
    float = concentration

targets(__differential)
    pass

    '''=====PLOTS======'''
    def map_overlap()           // heatmap
        pass
    def DPre()                  // Driver prediction (vert. barplots)
        pass







********** TODO ************

------------control problem

check user input more thouroughly (down marker genes, ctrl etc)

implement a devent logger system to show whats going on

-------------merge diff_intersection methods and implement norm properly

-------------catch labeloverlaps

------------make diff_intersection bidirectional

------------overwork colors

GENERAL Test figures witgh more unusual input sizes

overwork scaling for early plots

--------------implement singlegene_heatmap

--------------implement DPre

implement repr function

check expression obj better (NA, non numerical etc)

!!! restructure diff expr (make diff not required)

---------------for single gene hms, force 50 most intereseting genes if gl too long

!!! load drivers with control

fix methodnames

!!! froce control for driver initiation, cut difference_to args

-------------tidy up get_overlap_data! its a mess, get argument, dict with possible requests

default fontsize = 8

ensure driver names done't contain ' ' 

rcParam `figure.max_open_warning`
 
colorlegend function

--------------load overlap from file

new off target batch calculater...?...:))))

--------------down functionality for heatmaps

implement new width / total = ratio approach for all plots

make read write internal files binary

proper save implementation, png pdf blablabla

pad for abs distance bar label

single eff plots neg effects option...?:)

color getter cycles exceptions if label wrong.. terrible

overall distance option for single effects function

----------------exclude_single_predictions doenst work atm

option to override overlap load/ clear tmp etc

return axes, fig and data for all!@!!!!!!!!!

single colorbar funcitons and edgecolors etc blablabla

you added non differential to single effcects, add the correct labels!

fast track for get from overlap

convert_to_proportional for specify comb

check if elements >1 length for clustering

singe gene heatmap should list genes increasing in similarity most first

pads everywhere

implement groupby in get_from_overlap

eff, efs everywhere but now it can also be a distance, so change nameing ip

combine_drivers aaswell a sget_from_overlap should be writen without loops and groupby only!

!!!!high prio: fix the load overlap issues

overlap drivers with groupby.expand please

not expressed drop option?

cell identity for intersect through prop of mgs?

proper comp initiation

think about how different z variances between datasets effects the performance of the model
and weather its possible to reach 100% accuracy. Whats blocking it if not?

general data checker methends checking z data, distributions, consistency....


asseration checking for input types

